{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robo Documentation Getting Started Collections Extending Robo as a Framework Tasks ApiGen Archive Assets Base Bower Composer Development Docker File Filesystem Gulp Npm Remote Testing Vcs","title":"Index"},{"location":"#robo-documentation","text":"Getting Started Collections Extending Robo as a Framework","title":"Robo Documentation"},{"location":"#tasks","text":"ApiGen Archive Assets Base Bower Composer Development Docker File Filesystem Gulp Npm Remote Testing Vcs","title":"Tasks"},{"location":"collections/","text":"Collection Builders Robo provides task collections as a means of making error detection and recovery easier. When Robo tasks are added to a collection, their execution is deferred until the $collection->run() method is called. If one of the tasks fail, then the operation will be aborted; rollback tasks may also be defined to restore the system to its original condition. When using collections, a Robo script will go through three phases: Determine which tasks will need to be run, and create a task builder. Assign values to variables. Do not alter the state of the system. Create the necessary tasks via the task builder. Use variables calculated in the first phase in task parameters. Run the tasks via the run() method. Check and report errors once after run() returns. Following this pattern will keep your code linear and easy to understand. Collections API Collections are made up of a combination of tasks and/or callable functions / method pointers, such as: A task (implements TaskInterface) A function name (string) A closure (inline function) A method reference (array with object and method name) Examples of adding different kinds of tasks to a collection are provided below. TaskInterface Objects <?php $collection->add( $this->taskExec('ls') ); ?> Functions <?php $collection->addCode('mytaskfunction'); ?> Closures <?php $collection->addCode( function() use ($work) { // do something with $work }); ?> Methods <?php $collection->addCode([$myobject, 'mymethod']); ?> Using a Collection Builder To manage a collection of tasks, use a collection builder. Collection builders allow tasks to be created via chained methods. All of the tasks created by the same builder are added to a collection; when the run() method is called, all of the tasks in the collection run. The 'publish' command from Robo's own RoboFile is shown below. It uses a collection builder to run some git and filesystem operations. The \"completion\" tasks are run after all other tasks complete, or during rollback processing when an operation fails. <?php class RoboFile extends \\Robo\\Tasks { public function publish(ConsoleIO $io) { $current_branch = exec('git rev-parse --abbrev-ref HEAD'); $collection = $this->collectionBuilder($io); $collection->taskGitStack() ->checkout('site') ->merge('master') ->completion($this->taskGitStack()->checkout($current_branch)) ->taskFilesystemStack() ->copy('CHANGELOG.md', 'docs/changelog.md') ->completion($this->taskFilesystemStack()->remove('docs/changelog.md')) ->taskExec('mkdocs gh-deploy'); return $collection; } } ?> The example above also adds a couple of tasks as \"completions\"; these are run when the collection completes execution, as explained below. Rollbacks and Completions Robo also provides rollbacks and completions, special tasks that are eligible to run only if all of the tasks added to the collection before them succeed. The section below explains the circumstances under which these tasks will run. Completion Tasks Completions run whenever their collection completes or fails, but only if all of the tasks that come before it succeed. An example of this is shown in the first example above. A filesystem stack task copies CHANDELOG.md to docs/changelog.md; after this task is added to the collection, another filesystem stack task is added as a completion to delete docs/changelog.md. This is done because docs/changelog.md is only intended to exist long enough to be used by the mkdocs task, which is added later. Rollback Tasks In addition to completions, Robo also supports rollbacks. Rollback tasks can be used to clean up after failures, so the state of the system does not change when execution is interrupted by an error. A rollback task is executed if all of the tasks that come before it succeed, and at least one of the tasks that come after it fails. If all tasks succeed, then no rollback tasks are executed. Rollback and Completion Methods Any task may also implement \\Robo\\Contract\\RollbackInterface; if this is done, then its rollback() method will be called if the task is run() on a collection that later fails. Use addAsCompletion($collection) in place of addAsRollback($collection) , or implement \\Robo\\Contract\\CompletionInterface. Completions otherwise work exactly like rollbacks. By default, rollbacks and completions tasks or callbacks continue even if errors occur. If you would like to explicitly cancel or abort the rollback or completion, you may throw the \\Robo\\Exception\\AbortTasksException exception. Rollback and Completion Callbacks You may also provide arbitrary methods as callable s to serve as rollback or completion functions, as shown below: <?php $collection->rollbackCode([$myobject, 'myrollback']); $collection->completionCode([$myobject, 'mycompletion']); ?> Temporary Objects Since the concept of temporary objects that are cleaned up on failure is a common pattern, Robo provides built-in support for them. Temporary directories and files are provided out of the box; other kinds of temporary objects can be easily created using the Temporary global collection. Temporary Directories It is recommended that operations that perform multiple filesystem operations should, whenever possible, do most of their work in a temporary directory. Temporary directories are created by $this->taskTmpDir() , and are automatically removed when the collection completes or rolls back. As an added convenience, the CollectionBuilder class has a tmpDir() method that creates a temporary directory via taskTmpDir() , and then returns the path to the temporary directory. <?php class RoboFile extends \\Robo\\Tasks { function myOperation(ConsoleIO $io) { $collection = $this->collectionBuilder($io); // Create a temporary directory, and fetch its path. $work = $collection->tmpDir(); $collection ->taskWriteToFile(\"$work/README.md\") ->line('-----') ->line(date('Y-m-d').' Generated file: do not edit.') ->line('----'); // If all of the preceding tasks succeed, then rename the temporary // directory to its final name. $collection->taskFilesystemStack() ->rename($work, 'destination'); return $collection->run(); } } ?> In the previous example, the path to the temporary directory is stored in the variable $work , and is passed as needed to the parameters of the other tasks as they are added to the collection. After the task collection is run, the temporary directory will be automatically deleted. In the example above, the temporary directory is renamed by the last task in the collection. This allows the working directory to persist; the collection will still attempt to remove the working directory, but no errors will be thrown if it no longer exists in its original location. Following this pattern allows Robo scripts to easily and safely do work that cleans up after itself on failure, without introducing a lot of branching or additional error recovery code. This paradigm is common enough to warrant a shortcut method of accomplishing the same thing. The example below is identical to the one above, save for the fact that it uses the workDir() method instead of tmpDir() . workDir() renames the temporary directory to its final name if the collection completes; any directory that exists in the same location will be overwritten at that time, but will persist if the collection roles back. <?php class RoboFile extends \\Robo\\Tasks { function myOperation(ConsoleIO $io) { $collection = $this->collectionBuilder($io); // Create a temporary directory, and fetch its path. // If all of the tasks succeed, then rename the temporary directory // to its final name. $work = $collection->workDir('destination'); $collection ->taskWriteToFile(\"$work/README.md\") ->line('-----') ->line(date('Y-m-d').' Generated file: do not edit.') ->line('----'); return $collection->run(); } } ?> Temporary directories may also be created via the shortcut $this->_tmpDir(); . Temporary directories created in this way are deleted when the script terminates. Temporary Files Robo also provides an API for creating temporary files. They may be created via $this->taskTmpFile() ; they are used exactly like $this->taskWrite() , except they are given a random name on creation, and are deleted when their collection completes. If they are not added to a collection, then they are deleted when the script terminates. The Temporary Global Collection Robo maintains a special collection called the Temporary global collection. This collection is used to keep track of temporary objects that are not part of any collection. For example, Robo temporary directories and temporary files are managed by the Temporary global collection. These temporary objects are cleaned up automatically when the script terminates. It is easy to create your own temporary tasks that behave in the same way as the provided temporary directory and temporary file tasks. There are two steps required: Implement \\Robo\\Contract\\CompletionInterface Wrap the task via Temporary::wrap() For example, the implementation of taskTmpFile() looks like this: <?php protected function taskTmpFile($filename = 'tmp', $extension = '', $baseDir = '', $includeRandomPart = true) { return Temporary::wrap(new TmpFile($filename, $extension, $baseDir, $includeRandomPart)); } ?> The complete() method of the task will be called once the Collection the temporary object is attached to finishes running. If the temporary is not added to a collection, then its complete() method will be called when the script terminates. Chained State When using a collection builder, it is possible to pass state from one task to another. State is generated during the run() method of each task, and returned in a Robo\\Result object. Each result has a \"message\" and a key/value data store that contains the task's state. This state can be made available to later tasks in the builder. Implicitly Passing State Sometimes it may be desirable to process the files produced by one task using a following task that alters the result. For example, if you have one task that takes a set of source files and generates destination files, and another task that encrypts a set of files, you could encrypt the results from the first task by running both of the tasks independently: <?php $result = $this->taskGenerate() ->files($sources) ->run(); $result = $this->taskEncrypt() ->files($result['files']) ->run(); ?> If the Encrypt task implements \\Robo\\State\\Consumer and accepts 'files' from the current state, then these tasks may be chained together as follows: <?php $collection = $this->collectionBuilder($io); $collection ->taskGenerate() ->files($sources) ->taskEncrypt() ->run(); ?> Tasks that do not implement the Consumer interface may still be chained together by explicitly connecting the state from one task with the task configuration methods, as explained in the following section: Explicitly Passing State State from the key/value data store, if set, is automatically stored in the collection's state. The storeState() method can be used to store the result \"message\". To pass state from one task to another, the deferTaskConfiguration() method may be used. This method defers initialization until immediately before the task's run() method is called. It then calls a single named setter method, passing it the value of some state variable. For example, the builder below will create a new directory named after the output of the uname -n command returned by taskExec. Note that it is necessary to call printOutput(false) in order to make the output of taskExec available to the state system. <?php $this->collectionBuilder($io) ->taskExec('uname -n') ->printOutput(false) ->storeState('system-name') ->taskFilesystemStack() ->deferTaskConfiguration('mkdir', 'system-name') ->run(); ?> More complex task configuration may be done via the defer() method. defer() works like deferTaskConfiguration() , except that it will run an arbitrary callable immediately prior to the execution of the task. The example below works exactly the same as the previous example, but is implemented using defer() instead of deferTaskConfiguration() . <?php $this->collectionBuilder($io) ->taskExec('uname -n') ->printOutput(false) ->storeState('system-name') ->taskFilesystemStack() ->defer( function ($task, $state) { $task->mkdir($state['system-name']); } ) ->run(); ?> In general, it is preferable to collect all of the information needed first, and then use that data to configure the necessary tasks. For example, the previous example could be implemented more simply by calling $system_name = exec('uname -n'); and taskFilesystemStack->mkdir($system_name); . Chained state can be helpful in instances where there is a more complex relationship between the tasks. Named Tasks It is also possible to provide names for the tasks added to a collection. This has two primary benefits: Any result data returned from a named task is stored in the Result object under the task name. It is possible for other code to add more tasks before or after any named task. This feature is useful if you have functions that create task collections, and return them as a function results. The original caller can then use the $collection->before() or $collection->after() to insert sequenced tasks into the set of operations to be performed. One reason this might be done would be to define a base set of operations to perform (e.g. in a deploy), and then apply modifications for other environments (e.g. dev or stage). <?php $collection->addCode( function() use ($work) { // do something with $work }, \"taskname\"); ?> Given a collection with named tasks, it is possible to insert more tasks before or after a task of a given name. <?php $collection->after(\"taskname\", function() use ($work) { // do something with $work after \"taskname\" executes, if it succeeds. }); ?> <?php $collection->before(\"taskname\", function() use ($work) { // do something with $work before \"taskname\" executes. }); ?> It is recommended that named tasks be avoided unless specifically needed.","title":"Collection Builders"},{"location":"collections/#collection-builders","text":"Robo provides task collections as a means of making error detection and recovery easier. When Robo tasks are added to a collection, their execution is deferred until the $collection->run() method is called. If one of the tasks fail, then the operation will be aborted; rollback tasks may also be defined to restore the system to its original condition. When using collections, a Robo script will go through three phases: Determine which tasks will need to be run, and create a task builder. Assign values to variables. Do not alter the state of the system. Create the necessary tasks via the task builder. Use variables calculated in the first phase in task parameters. Run the tasks via the run() method. Check and report errors once after run() returns. Following this pattern will keep your code linear and easy to understand.","title":"Collection Builders"},{"location":"collections/#collections-api","text":"Collections are made up of a combination of tasks and/or callable functions / method pointers, such as: A task (implements TaskInterface) A function name (string) A closure (inline function) A method reference (array with object and method name) Examples of adding different kinds of tasks to a collection are provided below.","title":"Collections API"},{"location":"collections/#taskinterface-objects","text":"<?php $collection->add( $this->taskExec('ls') ); ?>","title":"TaskInterface Objects"},{"location":"collections/#functions","text":"<?php $collection->addCode('mytaskfunction'); ?>","title":"Functions"},{"location":"collections/#closures","text":"<?php $collection->addCode( function() use ($work) { // do something with $work }); ?>","title":"Closures"},{"location":"collections/#methods","text":"<?php $collection->addCode([$myobject, 'mymethod']); ?>","title":"Methods"},{"location":"collections/#using-a-collection-builder","text":"To manage a collection of tasks, use a collection builder. Collection builders allow tasks to be created via chained methods. All of the tasks created by the same builder are added to a collection; when the run() method is called, all of the tasks in the collection run. The 'publish' command from Robo's own RoboFile is shown below. It uses a collection builder to run some git and filesystem operations. The \"completion\" tasks are run after all other tasks complete, or during rollback processing when an operation fails. <?php class RoboFile extends \\Robo\\Tasks { public function publish(ConsoleIO $io) { $current_branch = exec('git rev-parse --abbrev-ref HEAD'); $collection = $this->collectionBuilder($io); $collection->taskGitStack() ->checkout('site') ->merge('master') ->completion($this->taskGitStack()->checkout($current_branch)) ->taskFilesystemStack() ->copy('CHANGELOG.md', 'docs/changelog.md') ->completion($this->taskFilesystemStack()->remove('docs/changelog.md')) ->taskExec('mkdocs gh-deploy'); return $collection; } } ?> The example above also adds a couple of tasks as \"completions\"; these are run when the collection completes execution, as explained below.","title":"Using a Collection Builder"},{"location":"collections/#rollbacks-and-completions","text":"Robo also provides rollbacks and completions, special tasks that are eligible to run only if all of the tasks added to the collection before them succeed. The section below explains the circumstances under which these tasks will run.","title":"Rollbacks and Completions"},{"location":"collections/#completion-tasks","text":"Completions run whenever their collection completes or fails, but only if all of the tasks that come before it succeed. An example of this is shown in the first example above. A filesystem stack task copies CHANDELOG.md to docs/changelog.md; after this task is added to the collection, another filesystem stack task is added as a completion to delete docs/changelog.md. This is done because docs/changelog.md is only intended to exist long enough to be used by the mkdocs task, which is added later.","title":"Completion Tasks"},{"location":"collections/#rollback-tasks","text":"In addition to completions, Robo also supports rollbacks. Rollback tasks can be used to clean up after failures, so the state of the system does not change when execution is interrupted by an error. A rollback task is executed if all of the tasks that come before it succeed, and at least one of the tasks that come after it fails. If all tasks succeed, then no rollback tasks are executed.","title":"Rollback Tasks"},{"location":"collections/#rollback-and-completion-methods","text":"Any task may also implement \\Robo\\Contract\\RollbackInterface; if this is done, then its rollback() method will be called if the task is run() on a collection that later fails. Use addAsCompletion($collection) in place of addAsRollback($collection) , or implement \\Robo\\Contract\\CompletionInterface. Completions otherwise work exactly like rollbacks. By default, rollbacks and completions tasks or callbacks continue even if errors occur. If you would like to explicitly cancel or abort the rollback or completion, you may throw the \\Robo\\Exception\\AbortTasksException exception.","title":"Rollback and Completion Methods"},{"location":"collections/#rollback-and-completion-callbacks","text":"You may also provide arbitrary methods as callable s to serve as rollback or completion functions, as shown below: <?php $collection->rollbackCode([$myobject, 'myrollback']); $collection->completionCode([$myobject, 'mycompletion']); ?>","title":"Rollback and Completion Callbacks"},{"location":"collections/#temporary-objects","text":"Since the concept of temporary objects that are cleaned up on failure is a common pattern, Robo provides built-in support for them. Temporary directories and files are provided out of the box; other kinds of temporary objects can be easily created using the Temporary global collection.","title":"Temporary Objects"},{"location":"collections/#temporary-directories","text":"It is recommended that operations that perform multiple filesystem operations should, whenever possible, do most of their work in a temporary directory. Temporary directories are created by $this->taskTmpDir() , and are automatically removed when the collection completes or rolls back. As an added convenience, the CollectionBuilder class has a tmpDir() method that creates a temporary directory via taskTmpDir() , and then returns the path to the temporary directory. <?php class RoboFile extends \\Robo\\Tasks { function myOperation(ConsoleIO $io) { $collection = $this->collectionBuilder($io); // Create a temporary directory, and fetch its path. $work = $collection->tmpDir(); $collection ->taskWriteToFile(\"$work/README.md\") ->line('-----') ->line(date('Y-m-d').' Generated file: do not edit.') ->line('----'); // If all of the preceding tasks succeed, then rename the temporary // directory to its final name. $collection->taskFilesystemStack() ->rename($work, 'destination'); return $collection->run(); } } ?> In the previous example, the path to the temporary directory is stored in the variable $work , and is passed as needed to the parameters of the other tasks as they are added to the collection. After the task collection is run, the temporary directory will be automatically deleted. In the example above, the temporary directory is renamed by the last task in the collection. This allows the working directory to persist; the collection will still attempt to remove the working directory, but no errors will be thrown if it no longer exists in its original location. Following this pattern allows Robo scripts to easily and safely do work that cleans up after itself on failure, without introducing a lot of branching or additional error recovery code. This paradigm is common enough to warrant a shortcut method of accomplishing the same thing. The example below is identical to the one above, save for the fact that it uses the workDir() method instead of tmpDir() . workDir() renames the temporary directory to its final name if the collection completes; any directory that exists in the same location will be overwritten at that time, but will persist if the collection roles back. <?php class RoboFile extends \\Robo\\Tasks { function myOperation(ConsoleIO $io) { $collection = $this->collectionBuilder($io); // Create a temporary directory, and fetch its path. // If all of the tasks succeed, then rename the temporary directory // to its final name. $work = $collection->workDir('destination'); $collection ->taskWriteToFile(\"$work/README.md\") ->line('-----') ->line(date('Y-m-d').' Generated file: do not edit.') ->line('----'); return $collection->run(); } } ?> Temporary directories may also be created via the shortcut $this->_tmpDir(); . Temporary directories created in this way are deleted when the script terminates.","title":"Temporary Directories"},{"location":"collections/#temporary-files","text":"Robo also provides an API for creating temporary files. They may be created via $this->taskTmpFile() ; they are used exactly like $this->taskWrite() , except they are given a random name on creation, and are deleted when their collection completes. If they are not added to a collection, then they are deleted when the script terminates.","title":"Temporary Files"},{"location":"collections/#the-temporary-global-collection","text":"Robo maintains a special collection called the Temporary global collection. This collection is used to keep track of temporary objects that are not part of any collection. For example, Robo temporary directories and temporary files are managed by the Temporary global collection. These temporary objects are cleaned up automatically when the script terminates. It is easy to create your own temporary tasks that behave in the same way as the provided temporary directory and temporary file tasks. There are two steps required: Implement \\Robo\\Contract\\CompletionInterface Wrap the task via Temporary::wrap() For example, the implementation of taskTmpFile() looks like this: <?php protected function taskTmpFile($filename = 'tmp', $extension = '', $baseDir = '', $includeRandomPart = true) { return Temporary::wrap(new TmpFile($filename, $extension, $baseDir, $includeRandomPart)); } ?> The complete() method of the task will be called once the Collection the temporary object is attached to finishes running. If the temporary is not added to a collection, then its complete() method will be called when the script terminates.","title":"The Temporary Global Collection"},{"location":"collections/#chained-state","text":"When using a collection builder, it is possible to pass state from one task to another. State is generated during the run() method of each task, and returned in a Robo\\Result object. Each result has a \"message\" and a key/value data store that contains the task's state. This state can be made available to later tasks in the builder.","title":"Chained State"},{"location":"collections/#implicitly-passing-state","text":"Sometimes it may be desirable to process the files produced by one task using a following task that alters the result. For example, if you have one task that takes a set of source files and generates destination files, and another task that encrypts a set of files, you could encrypt the results from the first task by running both of the tasks independently: <?php $result = $this->taskGenerate() ->files($sources) ->run(); $result = $this->taskEncrypt() ->files($result['files']) ->run(); ?> If the Encrypt task implements \\Robo\\State\\Consumer and accepts 'files' from the current state, then these tasks may be chained together as follows: <?php $collection = $this->collectionBuilder($io); $collection ->taskGenerate() ->files($sources) ->taskEncrypt() ->run(); ?> Tasks that do not implement the Consumer interface may still be chained together by explicitly connecting the state from one task with the task configuration methods, as explained in the following section:","title":"Implicitly Passing State"},{"location":"collections/#explicitly-passing-state","text":"State from the key/value data store, if set, is automatically stored in the collection's state. The storeState() method can be used to store the result \"message\". To pass state from one task to another, the deferTaskConfiguration() method may be used. This method defers initialization until immediately before the task's run() method is called. It then calls a single named setter method, passing it the value of some state variable. For example, the builder below will create a new directory named after the output of the uname -n command returned by taskExec. Note that it is necessary to call printOutput(false) in order to make the output of taskExec available to the state system. <?php $this->collectionBuilder($io) ->taskExec('uname -n') ->printOutput(false) ->storeState('system-name') ->taskFilesystemStack() ->deferTaskConfiguration('mkdir', 'system-name') ->run(); ?> More complex task configuration may be done via the defer() method. defer() works like deferTaskConfiguration() , except that it will run an arbitrary callable immediately prior to the execution of the task. The example below works exactly the same as the previous example, but is implemented using defer() instead of deferTaskConfiguration() . <?php $this->collectionBuilder($io) ->taskExec('uname -n') ->printOutput(false) ->storeState('system-name') ->taskFilesystemStack() ->defer( function ($task, $state) { $task->mkdir($state['system-name']); } ) ->run(); ?> In general, it is preferable to collect all of the information needed first, and then use that data to configure the necessary tasks. For example, the previous example could be implemented more simply by calling $system_name = exec('uname -n'); and taskFilesystemStack->mkdir($system_name); . Chained state can be helpful in instances where there is a more complex relationship between the tasks.","title":"Explicitly Passing State"},{"location":"collections/#named-tasks","text":"It is also possible to provide names for the tasks added to a collection. This has two primary benefits: Any result data returned from a named task is stored in the Result object under the task name. It is possible for other code to add more tasks before or after any named task. This feature is useful if you have functions that create task collections, and return them as a function results. The original caller can then use the $collection->before() or $collection->after() to insert sequenced tasks into the set of operations to be performed. One reason this might be done would be to define a base set of operations to perform (e.g. in a deploy), and then apply modifications for other environments (e.g. dev or stage). <?php $collection->addCode( function() use ($work) { // do something with $work }, \"taskname\"); ?> Given a collection with named tasks, it is possible to insert more tasks before or after a task of a given name. <?php $collection->after(\"taskname\", function() use ($work) { // do something with $work after \"taskname\" executes, if it succeeds. }); ?> <?php $collection->before(\"taskname\", function() use ($work) { // do something with $work before \"taskname\" executes. }); ?> It is recommended that named tasks be avoided unless specifically needed.","title":"Named Tasks"},{"location":"extending/","text":"Extending Robo tasks can be added to your Robo application by using Composer to suppliment the set of built-in tasks that Robo provides by default. To find existing Robo task extensions, search in Packagist for projects of type robo-tasks . The convention used to add new tasks for use in your RoboFiles is to create a wrapper trait named Tasks in your namespace that instantiates the implementation class for each task. Each task method in the trait should start with the prefix task , and should use chained method calls for configuration. Task execution should be triggered by the method run . To include additional tasks in your RoboFile, you must use the appropriate Tasks in your RoboFile. See the section Including Additional Tasks below. To create your own Robo extension that provides tasks for use in RoboFiles, then you must write your own class that implements TaskInterface, and create a Tasks trait for it as described in the section Creating a Robo Extension . Note: The Tasks traits are called loadTasks in Robo core. This is a legacy name, preserved for backwards compatibility purposes. These traits will all be renamed to Tasks in Robo 2.0. Including Additional Tasks Additional tasks may be installed into projects that have included Robo via Composer. For example: $ cd myproject $ composer require boedah/robo-drush If any of the tasks you include require external Composer projects themselves, then you must composer require these as well. See the suggests section of Robo's composer.json file for a list of some projects you might need to require. Once the extension you wish to use has been added to your vendor directory, you may then include it from your RoboFile: class RoboFile extends \\Robo\\Tasks { use Boedah\\Robo\\Task\\Drush\\Tasks; public function test(ConsoleIO $io) { // ... } } Once you have done this, all of the tasks defined in the extension you selected will be available for use in your commands. Note that at the moment, it is not possible to extend Robo when using the robo.phar. This capability may be added in the future via embedded composer . Register command files via PSR-4 autoloading You can have your project expose extra Robo command files by providing them within your project's PSR-4 namespace. For example, given the following PSR-4 namespace in your composer.json : { \"autoload\": { \"psr-4\": { \"MyProject\\\\\": \"./src/\" } } } Extra command files can be exposed by creating one or more classes under ./src/Robo/Plugin/Commands , as shown in the example below: <?php namespace MyProject\\Robo\\Plugin\\Commands; use Robo\\Symfony\\ConsoleIO; class MyCustomCommands extends \\Robo\\Tasks { /** * @command my-project:command-one */ public function commandOne(ConsoleIO $io) { } /** * @command my-project:command-two */ public function commandTwo(ConsoleIO $io) { } } Please note: command files classes must be placed under Robo/Plugin/Commands relative namespace and their name must end in Command.php or Commands.php . You can now access your new commands via Robo: $ ./vendor/bin/robo $ ./robo Robo 1.2.2-dev Usage: command [options] [arguments] ... Available commands: help Displays help for a command list Lists commands my-project my-project:command-one my-project:command-two Creating a Robo Extension A Robo tasks extension is created by advertising a Composer package of type robo-tasks on Packagist . For an overview on how this is done, see the article Creating your very own Composer Package . Specific instructions for creating Robo task extensions are provided below. Create your composer.json File Your composer.json file should look something like the example below: { \"name\": \"boedah/robo-drush\", \"description\": \"Drush CommandStack for Robo Task Runner\", \"type\": \"robo-tasks\", \"autoload\": { \"psr-4\": { \"Boedah\\\\Robo\\\\Task\\\\Drush\\\\\": \"src\" } }, \"require\": { \"php\": \">=5.5.0\", \"consolidation/robo\": \"~1\" } } Customize the name and autoload paths as necessary, and add any additional required projects needed by the tasks that your extensions will provide. The type of your project should always be robo-tasks . Robo only supports php >= 5.5.0; you may require a higher version of php if necessary. Create the Tasks.php Trait It is recommended to place your trait-loading task in a Tasks file in the same namespace as the task implementation. namespace Boedah\\Robo\\Task\\Drush; trait Tasks { /** * @param string $pathToDrush * @return DrushStack */ protected function taskDrushStack($pathToDrush = 'drush') { return $this->task(__FUNCTION__, $pathToDrush); } } Note that the name of the service for a given task must start with the word \"task\", and must have the same name as the function used to call the task. $this->task() looks up the service by name; using the PHP built-in constant FUNCTION for this parameter ensures that the names of these items remain in alignment. Task implementation The implementation of each task class should extend \\Robo\\Task\\BaseTask, or some class that extends the same, and should used chained initializer methods and defer all operations that alter the state of the system until its run() method. If you follow these patterns, then your task extensions will be usable via Robo collection builders, as explained in the collections documentation. There are many examples of task implementations in the Robo\\Task namespace. A very basic task example is provided below. The namespace is MyAssetTasks , and the example task is CompileAssets . To customize to your purposes, choose an appropriate namespace, and then define as many tasks as you need. <?php namespace MyAssetTasks; trait Tasks { /** * Example task to compile assets * * @param string $pathToCompileAssets * @return \\MyAssetTasks\\CompileAssets */ protected function taskCompileAssets($path = null) { // Always construct your tasks with the `task()` task builder. return $this->task(CompileAssets::class, $path); } } class CompileAssets implements \\Robo\\Contract\\TaskInterface { // configuration params protected $path; protected $to; function __construct($path) { $this->path = $path; } function to($filename) { $this->to = $filename; // must return $this return $this; } // must implement Run function run() { //.... } } ?> To use the tasks you define in a RoboFile, use its Tasks trait as explained in the section Including Additional Tasks , above. TaskIO To allow tasks access IO, use the Robo\\Common\\TaskIO trait, or inherit your task class from Robo\\Task\\BaseTask (recommended). Inside tasks you should print process details with printTaskInfo , printTaskSuccess , and printTaskError . $this->printTaskInfo('Processing...'); The Task IO methods send all output through a PSR-3 logger. Tasks should use task IO exclusively; methods such as 'say' and 'ask' should reside in the command method. This allows tasks to be usable in any context that has a PSR-3 logger, including background or server processes where it is not possible to directly query the user. Tasks That Use Tasks If one task implementation needs to use other tasks while it is running, it should do so via a CollectionBuilder object, as explained in the Collections documentation. To obtain access to a CollectionBuilder , a task should implement BuilderAwareInterface and use BuilderAwareTrait . It will then have access to a collection builder via the $this->collectionBuilder() method. Testing Extensions If you wish to use the task() methods from your Tasks trait in your unit tests, it is necessary to also use the Robo TaskAccessor trait, and define a collectionBuilder() method to provide a builder. Collection builders are used to initialize all Robo tasks. The easiest way to get a usable collection builder in your tests is to initialize Robo's default dependency injection container, and use it to request a new builder. An example of how to do this in a PHPUnit test is shown below. use League\\Container\\ContainerAwareInterface; use League\\Container\\ContainerAwareTrait; use Symfony\\Component\\Console\\Output\\NullOutput; use Robo\\TaskAccessor; use Robo\\Robo; use Robo\\Collection\\CollectionBuilder; class DrushStackTest extends \\PHPUnit_Framework_TestCase implements ContainerAwareInterface { use \\Boedah\\Robo\\Task\\Drush\\Tasks; use TaskAccessor; use ContainerAwareTrait; // Set up the Robo container so that we can create tasks in our tests. function setup() { $container = Robo::createDefaultContainer(null, new NullOutput()); $this->setContainer($container); } // Scaffold the collection builder public function collectionBuilder() { $emptyRobofile = new \\Robo\\Tasks; return CollectionBuilder::create($this->getContainer(), $emptyRobofile); } public function testYesIsAssumed() { $command = $this->taskDrushStack() ->drush('command') ->getCommand(); $this->assertEquals('drush command -y', $command); } } To assert that the output of a command contains some value, use a Symfony\\Component\\Console\\Output\\BufferedOutput in place of null output when calling Robo::createDefaultContainer().","title":"Extending"},{"location":"extending/#extending","text":"Robo tasks can be added to your Robo application by using Composer to suppliment the set of built-in tasks that Robo provides by default. To find existing Robo task extensions, search in Packagist for projects of type robo-tasks . The convention used to add new tasks for use in your RoboFiles is to create a wrapper trait named Tasks in your namespace that instantiates the implementation class for each task. Each task method in the trait should start with the prefix task , and should use chained method calls for configuration. Task execution should be triggered by the method run . To include additional tasks in your RoboFile, you must use the appropriate Tasks in your RoboFile. See the section Including Additional Tasks below. To create your own Robo extension that provides tasks for use in RoboFiles, then you must write your own class that implements TaskInterface, and create a Tasks trait for it as described in the section Creating a Robo Extension . Note: The Tasks traits are called loadTasks in Robo core. This is a legacy name, preserved for backwards compatibility purposes. These traits will all be renamed to Tasks in Robo 2.0.","title":"Extending"},{"location":"extending/#including-additional-tasks","text":"Additional tasks may be installed into projects that have included Robo via Composer. For example: $ cd myproject $ composer require boedah/robo-drush If any of the tasks you include require external Composer projects themselves, then you must composer require these as well. See the suggests section of Robo's composer.json file for a list of some projects you might need to require. Once the extension you wish to use has been added to your vendor directory, you may then include it from your RoboFile: class RoboFile extends \\Robo\\Tasks { use Boedah\\Robo\\Task\\Drush\\Tasks; public function test(ConsoleIO $io) { // ... } } Once you have done this, all of the tasks defined in the extension you selected will be available for use in your commands. Note that at the moment, it is not possible to extend Robo when using the robo.phar. This capability may be added in the future via embedded composer .","title":"Including Additional Tasks"},{"location":"extending/#register-command-files-via-psr-4-autoloading","text":"You can have your project expose extra Robo command files by providing them within your project's PSR-4 namespace. For example, given the following PSR-4 namespace in your composer.json : { \"autoload\": { \"psr-4\": { \"MyProject\\\\\": \"./src/\" } } } Extra command files can be exposed by creating one or more classes under ./src/Robo/Plugin/Commands , as shown in the example below: <?php namespace MyProject\\Robo\\Plugin\\Commands; use Robo\\Symfony\\ConsoleIO; class MyCustomCommands extends \\Robo\\Tasks { /** * @command my-project:command-one */ public function commandOne(ConsoleIO $io) { } /** * @command my-project:command-two */ public function commandTwo(ConsoleIO $io) { } } Please note: command files classes must be placed under Robo/Plugin/Commands relative namespace and their name must end in Command.php or Commands.php . You can now access your new commands via Robo: $ ./vendor/bin/robo $ ./robo Robo 1.2.2-dev Usage: command [options] [arguments] ... Available commands: help Displays help for a command list Lists commands my-project my-project:command-one my-project:command-two","title":"Register command files via PSR-4 autoloading"},{"location":"extending/#creating-a-robo-extension","text":"A Robo tasks extension is created by advertising a Composer package of type robo-tasks on Packagist . For an overview on how this is done, see the article Creating your very own Composer Package . Specific instructions for creating Robo task extensions are provided below.","title":"Creating a Robo Extension"},{"location":"extending/#create-your-composerjson-file","text":"Your composer.json file should look something like the example below: { \"name\": \"boedah/robo-drush\", \"description\": \"Drush CommandStack for Robo Task Runner\", \"type\": \"robo-tasks\", \"autoload\": { \"psr-4\": { \"Boedah\\\\Robo\\\\Task\\\\Drush\\\\\": \"src\" } }, \"require\": { \"php\": \">=5.5.0\", \"consolidation/robo\": \"~1\" } } Customize the name and autoload paths as necessary, and add any additional required projects needed by the tasks that your extensions will provide. The type of your project should always be robo-tasks . Robo only supports php >= 5.5.0; you may require a higher version of php if necessary.","title":"Create your composer.json File"},{"location":"extending/#create-the-tasksphp-trait","text":"It is recommended to place your trait-loading task in a Tasks file in the same namespace as the task implementation. namespace Boedah\\Robo\\Task\\Drush; trait Tasks { /** * @param string $pathToDrush * @return DrushStack */ protected function taskDrushStack($pathToDrush = 'drush') { return $this->task(__FUNCTION__, $pathToDrush); } } Note that the name of the service for a given task must start with the word \"task\", and must have the same name as the function used to call the task. $this->task() looks up the service by name; using the PHP built-in constant FUNCTION for this parameter ensures that the names of these items remain in alignment.","title":"Create the Tasks.php Trait"},{"location":"extending/#task-implementation","text":"The implementation of each task class should extend \\Robo\\Task\\BaseTask, or some class that extends the same, and should used chained initializer methods and defer all operations that alter the state of the system until its run() method. If you follow these patterns, then your task extensions will be usable via Robo collection builders, as explained in the collections documentation. There are many examples of task implementations in the Robo\\Task namespace. A very basic task example is provided below. The namespace is MyAssetTasks , and the example task is CompileAssets . To customize to your purposes, choose an appropriate namespace, and then define as many tasks as you need. <?php namespace MyAssetTasks; trait Tasks { /** * Example task to compile assets * * @param string $pathToCompileAssets * @return \\MyAssetTasks\\CompileAssets */ protected function taskCompileAssets($path = null) { // Always construct your tasks with the `task()` task builder. return $this->task(CompileAssets::class, $path); } } class CompileAssets implements \\Robo\\Contract\\TaskInterface { // configuration params protected $path; protected $to; function __construct($path) { $this->path = $path; } function to($filename) { $this->to = $filename; // must return $this return $this; } // must implement Run function run() { //.... } } ?> To use the tasks you define in a RoboFile, use its Tasks trait as explained in the section Including Additional Tasks , above.","title":"Task implementation"},{"location":"extending/#taskio","text":"To allow tasks access IO, use the Robo\\Common\\TaskIO trait, or inherit your task class from Robo\\Task\\BaseTask (recommended). Inside tasks you should print process details with printTaskInfo , printTaskSuccess , and printTaskError . $this->printTaskInfo('Processing...'); The Task IO methods send all output through a PSR-3 logger. Tasks should use task IO exclusively; methods such as 'say' and 'ask' should reside in the command method. This allows tasks to be usable in any context that has a PSR-3 logger, including background or server processes where it is not possible to directly query the user.","title":"TaskIO"},{"location":"extending/#tasks-that-use-tasks","text":"If one task implementation needs to use other tasks while it is running, it should do so via a CollectionBuilder object, as explained in the Collections documentation. To obtain access to a CollectionBuilder , a task should implement BuilderAwareInterface and use BuilderAwareTrait . It will then have access to a collection builder via the $this->collectionBuilder() method.","title":"Tasks That Use Tasks"},{"location":"extending/#testing-extensions","text":"If you wish to use the task() methods from your Tasks trait in your unit tests, it is necessary to also use the Robo TaskAccessor trait, and define a collectionBuilder() method to provide a builder. Collection builders are used to initialize all Robo tasks. The easiest way to get a usable collection builder in your tests is to initialize Robo's default dependency injection container, and use it to request a new builder. An example of how to do this in a PHPUnit test is shown below. use League\\Container\\ContainerAwareInterface; use League\\Container\\ContainerAwareTrait; use Symfony\\Component\\Console\\Output\\NullOutput; use Robo\\TaskAccessor; use Robo\\Robo; use Robo\\Collection\\CollectionBuilder; class DrushStackTest extends \\PHPUnit_Framework_TestCase implements ContainerAwareInterface { use \\Boedah\\Robo\\Task\\Drush\\Tasks; use TaskAccessor; use ContainerAwareTrait; // Set up the Robo container so that we can create tasks in our tests. function setup() { $container = Robo::createDefaultContainer(null, new NullOutput()); $this->setContainer($container); } // Scaffold the collection builder public function collectionBuilder() { $emptyRobofile = new \\Robo\\Tasks; return CollectionBuilder::create($this->getContainer(), $emptyRobofile); } public function testYesIsAssumed() { $command = $this->taskDrushStack() ->drush('command') ->getCommand(); $this->assertEquals('drush command -y', $command); } } To assert that the output of a command contains some value, use a Symfony\\Component\\Console\\Output\\BufferedOutput in place of null output when calling Robo::createDefaultContainer().","title":"Testing Extensions"},{"location":"framework/","text":"Robo as a Framework For a faster and better start to creating your own commandline application, please see the documentation in the g1a/starter project. There are multiple ways to use and package Robo scripts; a few of the alternatives are presented below. Creating a Standalone Phar with Robo It is possible to create a standalone phar that is implemented with Robo; doing this does not require the RoboFile to be located in the current working directory, or any particular location within your project. To achieve this, first set up your project as shown in the section Implementing Composer Scripts with Robo . Use of the \"scripts\" section is optional. Next, add an \"autoload\" section to your composer.json to provide a namespace for your Robo commands: { \"name\": \"myorg/myproject\", \"require\": { \"consolidation/Robo\": \"^2\" }, \"autoload\":{ \"psr-4\":{ \"MyProject\\\\\":\"src\" } } } Create a new file for your Robo commands, e.g. class RoboFile in namespace MyProject\\Commands; in the file src\\Commands\\RoboFile.php . Optionally, add more task libraries as described in the extending document. Create a startup script similar to the one below, and add it to the root of your project, or some other location of your choosing: #!/usr/bin/env php <?php // If we're running from phar load the phar autoload file. $pharPath = \\Phar::running(true); if ($pharPath) { $autoloaderPath = \"$pharPath/vendor/autoload.php\"; } else { if (file_exists(__DIR__.'/vendor/autoload.php')) { $autoloaderPath = __DIR__.'/vendor/autoload.php'; } elseif (file_exists(__DIR__.'/../../autoload.php')) { $autoloaderPath = __DIR__ . '/../../autoload.php'; } else { die(\"Could not find autoloader. Run 'composer install'.\"); } } $classLoader = require $autoloaderPath; // Customization variables $appName = \"MyAppName\"; $appVersion = trim(file_get_contents(__DIR__ . '/VERSION')); $commandClasses = [ \\MyProject\\Commands\\RoboFile::class ]; $selfUpdateRepository = 'myorg/myproject'; $configurationFilename = 'myconfig.yml'; // Define our Runner, and pass it the command classes we provide. $runner = new \\Robo\\Runner($commandClasses); $runner ->setSelfUpdateRepository($selfUpdateRepository) ->setConfigurationFilename($configurationFilename) ->setClassLoader($classLoader); // Execute the command and return the result. $output = new \\Symfony\\Component\\Console\\Output\\ConsoleOutput(); $statusCode = $runner->execute($argv, $appName, $appVersion, $output); exit($statusCode); When using Robo as a framework, the Robo file should be included in the autoloader, as Robo does not include a RoboFile.php file when used in this mode. Instead, specify the class or classes to load as a parameter to the Robo\\Runner constructor. Use box-project/box2 or Robo's taskPackPhar to create a phar for your application. If your application's repository is hosted on GitHub, then passing the appropriate GitHub org/project to the \\Robo\\Robo::run() method, as shown above, will enable the self:update command to automatically update to the latest available version. Note that self:update only works with phar distributions. Using Multiple RoboFiles in a Standalone Application It is possible to provide as many command classes as you wish to the Robo Runner() constructor. You might wish to separate your Robo command implementations into separate Robo files if you have a lot of commands, or if you wish to group similar commands together in the same source file. If you do this, you can simply add more class references to the $commandClasses variable shown above. $commandClasses = [ \\MyProject\\Commands\\BuildCommands::class, \\MyProject\\Commands\\DeployCommands::class ]; If your application has a large number of command files, or if it supports command extensions, then you might wish to use the Command Discovery class to locate your files. The CommandFileDiscovery class will use the Symfony Finder class to search for all filenames matching the provided search pattern. It will return a list of class names using the provided base namespace. $discovery = new \\Consolidation\\AnnotatedCommand\\CommandFileDiscovery(); $discovery->setSearchPattern('*Command.php'); $commandClasses = $discovery->discover('php/MyProject/Commands', '\\MyProject\\Commands'); Pass the resulting $commandClasses to the Runner() constructor as shown above. See the annotated-commands project for more information about the different options that the discovery command takes. Using Your Own Dependency Injection Container with Robo (Advanced) It is also possible to completely replace the Robo application with your own. To do this, set up your project as described in the sections above, but replace the Robo runner with your own main event loop. Add the following to your startup file: <?php use League\\Container\\Container; use Robo\\Robo; $input = new \\Symfony\\Component\\Console\\Input\\ArgvInput($argv); $output = new \\Symfony\\Component\\Console\\Output\\ConsoleOutput(); $config = Robo::createConfiguration(['myconf.yml']); $app = new \\MyApplication($config, $input, $output); $status_code = $app->run($input, $output); exit($status_code); Then, create your own custom application: <?php use Robo\\Common\\ConfigAwareTrait; use Robo\\Config; use Robo\\Robo; use Robo\\Runner as RoboRunner; use Symfony\\Component\\Console\\Application; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; class MyApplication { const APPLICATION_NAME = 'My Application'; const REPOSITORY = 'org/project'; use ConfigAwareTrait; private $runner; public function __construct( Config $config, InputInterface $input = NULL, OutputInterface $output = NULL ) { // Create applicaton. $this->setConfig($config); $application = new Application(self::APPLICATION_NAME, $config->get('version')); // Create and configure container. $container = Robo::createContainer($application, $config); $container->add(MyCustomService::class); // optional Robo::finalizeContainer($container); // Instantiate Robo Runner. $this->runner = new RoboRunner([ My\\Custom\\Command::class ]); $this->runner->setContainer($container); $this->runner->setSelfUpdateRepository(self::REPOSITORY); } public function run(InputInterface $input, OutputInterface $output) { $status_code = $this->runner->run($input, $output); return $status_code; } } If you are using League\\Container (recommended), then you may simply add and share your own classes to the same container. If you are using some other DI container, then you should use delegate lookup to combine them. Using a Custom Configuration Loader Robo provides a very simple configuration loader. If you wish to use more capable loader, you may opt to do so. Replace the call to Robo::createConfiguration() with code similar to the following: use Robo\\Config\\Config; use Consolidation\\Config\\Loader\\YamlConfigLoader; use Consolidation\\Config\\Loader\\ConfigProcessor; $config = new Config(); $loader = new YamlConfigLoader(); $processor = new ConfigProcessor(); $processor->extend($loader->load('defaults.yml')); $processor->extend($loader->load('myconf.yml')); $config->import($processor->export()); You may also wish to subclass the provided Config and ConfigProcessor classes to customize their behavior. The example above presumes that the configuration object starts off empty. If you need to repeat this process to extend the configuration in a later stage, you should call $processor->add($config->export()); to ensure that the configuration processor is seeded with the previous configuration values. Any configuraiton loader that produces a nested array may be used in place of the config loaders and config processor shown in the example above. For example, if you wish to find configuration files in a certain set of directories, allow .yml or .xml configuration files, and validate the schema of your configuration files (to alert users of any syntax errors or unrecognized configuration values), you might want to consider Symfony/Config . Symfony/Config produces a clean array of configuration values; the result of $processor->processConfiguration() may be provided directly to Robo's $config->import() method.","title":"Robo as a Framework"},{"location":"framework/#robo-as-a-framework","text":"For a faster and better start to creating your own commandline application, please see the documentation in the g1a/starter project. There are multiple ways to use and package Robo scripts; a few of the alternatives are presented below.","title":"Robo as a Framework"},{"location":"framework/#creating-a-standalone-phar-with-robo","text":"It is possible to create a standalone phar that is implemented with Robo; doing this does not require the RoboFile to be located in the current working directory, or any particular location within your project. To achieve this, first set up your project as shown in the section Implementing Composer Scripts with Robo . Use of the \"scripts\" section is optional. Next, add an \"autoload\" section to your composer.json to provide a namespace for your Robo commands: { \"name\": \"myorg/myproject\", \"require\": { \"consolidation/Robo\": \"^2\" }, \"autoload\":{ \"psr-4\":{ \"MyProject\\\\\":\"src\" } } } Create a new file for your Robo commands, e.g. class RoboFile in namespace MyProject\\Commands; in the file src\\Commands\\RoboFile.php . Optionally, add more task libraries as described in the extending document. Create a startup script similar to the one below, and add it to the root of your project, or some other location of your choosing: #!/usr/bin/env php <?php // If we're running from phar load the phar autoload file. $pharPath = \\Phar::running(true); if ($pharPath) { $autoloaderPath = \"$pharPath/vendor/autoload.php\"; } else { if (file_exists(__DIR__.'/vendor/autoload.php')) { $autoloaderPath = __DIR__.'/vendor/autoload.php'; } elseif (file_exists(__DIR__.'/../../autoload.php')) { $autoloaderPath = __DIR__ . '/../../autoload.php'; } else { die(\"Could not find autoloader. Run 'composer install'.\"); } } $classLoader = require $autoloaderPath; // Customization variables $appName = \"MyAppName\"; $appVersion = trim(file_get_contents(__DIR__ . '/VERSION')); $commandClasses = [ \\MyProject\\Commands\\RoboFile::class ]; $selfUpdateRepository = 'myorg/myproject'; $configurationFilename = 'myconfig.yml'; // Define our Runner, and pass it the command classes we provide. $runner = new \\Robo\\Runner($commandClasses); $runner ->setSelfUpdateRepository($selfUpdateRepository) ->setConfigurationFilename($configurationFilename) ->setClassLoader($classLoader); // Execute the command and return the result. $output = new \\Symfony\\Component\\Console\\Output\\ConsoleOutput(); $statusCode = $runner->execute($argv, $appName, $appVersion, $output); exit($statusCode); When using Robo as a framework, the Robo file should be included in the autoloader, as Robo does not include a RoboFile.php file when used in this mode. Instead, specify the class or classes to load as a parameter to the Robo\\Runner constructor. Use box-project/box2 or Robo's taskPackPhar to create a phar for your application. If your application's repository is hosted on GitHub, then passing the appropriate GitHub org/project to the \\Robo\\Robo::run() method, as shown above, will enable the self:update command to automatically update to the latest available version. Note that self:update only works with phar distributions.","title":"Creating a Standalone Phar with Robo"},{"location":"framework/#using-multiple-robofiles-in-a-standalone-application","text":"It is possible to provide as many command classes as you wish to the Robo Runner() constructor. You might wish to separate your Robo command implementations into separate Robo files if you have a lot of commands, or if you wish to group similar commands together in the same source file. If you do this, you can simply add more class references to the $commandClasses variable shown above. $commandClasses = [ \\MyProject\\Commands\\BuildCommands::class, \\MyProject\\Commands\\DeployCommands::class ]; If your application has a large number of command files, or if it supports command extensions, then you might wish to use the Command Discovery class to locate your files. The CommandFileDiscovery class will use the Symfony Finder class to search for all filenames matching the provided search pattern. It will return a list of class names using the provided base namespace. $discovery = new \\Consolidation\\AnnotatedCommand\\CommandFileDiscovery(); $discovery->setSearchPattern('*Command.php'); $commandClasses = $discovery->discover('php/MyProject/Commands', '\\MyProject\\Commands'); Pass the resulting $commandClasses to the Runner() constructor as shown above. See the annotated-commands project for more information about the different options that the discovery command takes.","title":"Using Multiple RoboFiles in a Standalone Application"},{"location":"framework/#using-your-own-dependency-injection-container-with-robo-advanced","text":"It is also possible to completely replace the Robo application with your own. To do this, set up your project as described in the sections above, but replace the Robo runner with your own main event loop. Add the following to your startup file: <?php use League\\Container\\Container; use Robo\\Robo; $input = new \\Symfony\\Component\\Console\\Input\\ArgvInput($argv); $output = new \\Symfony\\Component\\Console\\Output\\ConsoleOutput(); $config = Robo::createConfiguration(['myconf.yml']); $app = new \\MyApplication($config, $input, $output); $status_code = $app->run($input, $output); exit($status_code); Then, create your own custom application: <?php use Robo\\Common\\ConfigAwareTrait; use Robo\\Config; use Robo\\Robo; use Robo\\Runner as RoboRunner; use Symfony\\Component\\Console\\Application; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; class MyApplication { const APPLICATION_NAME = 'My Application'; const REPOSITORY = 'org/project'; use ConfigAwareTrait; private $runner; public function __construct( Config $config, InputInterface $input = NULL, OutputInterface $output = NULL ) { // Create applicaton. $this->setConfig($config); $application = new Application(self::APPLICATION_NAME, $config->get('version')); // Create and configure container. $container = Robo::createContainer($application, $config); $container->add(MyCustomService::class); // optional Robo::finalizeContainer($container); // Instantiate Robo Runner. $this->runner = new RoboRunner([ My\\Custom\\Command::class ]); $this->runner->setContainer($container); $this->runner->setSelfUpdateRepository(self::REPOSITORY); } public function run(InputInterface $input, OutputInterface $output) { $status_code = $this->runner->run($input, $output); return $status_code; } } If you are using League\\Container (recommended), then you may simply add and share your own classes to the same container. If you are using some other DI container, then you should use delegate lookup to combine them.","title":"Using Your Own Dependency Injection Container with Robo (Advanced)"},{"location":"framework/#using-a-custom-configuration-loader","text":"Robo provides a very simple configuration loader. If you wish to use more capable loader, you may opt to do so. Replace the call to Robo::createConfiguration() with code similar to the following: use Robo\\Config\\Config; use Consolidation\\Config\\Loader\\YamlConfigLoader; use Consolidation\\Config\\Loader\\ConfigProcessor; $config = new Config(); $loader = new YamlConfigLoader(); $processor = new ConfigProcessor(); $processor->extend($loader->load('defaults.yml')); $processor->extend($loader->load('myconf.yml')); $config->import($processor->export()); You may also wish to subclass the provided Config and ConfigProcessor classes to customize their behavior. The example above presumes that the configuration object starts off empty. If you need to repeat this process to extend the configuration in a later stage, you should call $processor->add($config->export()); to ensure that the configuration processor is seeded with the previous configuration values. Any configuraiton loader that produces a nested array may be used in place of the config loaders and config processor shown in the example above. For example, if you wish to find configuration files in a certain set of directories, allow .yml or .xml configuration files, and validate the schema of your configuration files (to alert users of any syntax errors or unrecognized configuration values), you might want to consider Symfony/Config . Symfony/Config produces a clean array of configuration values; the result of $processor->processConfiguration() may be provided directly to Robo's $config->import() method.","title":"Using a Custom Configuration Loader"},{"location":"getting-started/","text":"Getting Started To begin you need to create a RoboFile. Just run robo init in your project directory: cd myproject robo init Your project directory may start out empty; Robo will create a new RoboFile.php for you. There will be RoboFile class which extends \\Robo\\Tasks , which includes all bundled tasks of Robo. <?php class RoboFile extends \\Robo\\Tasks { } ?> Commands All public methods of the RoboFile class will be treated as commands . You can run them from the CLI and pass arguments. <?php use Robo\\Symfony\\ConsoleIO; class RoboFile extends \\Robo\\Tasks { function hello(ConsoleIO $io, $world) { $io->say(\"Hello, $world\"); } } ?> Note: The class ConsoleIO isa SymfonyStyle, and therefore has access to all of the Symfony styling methods. It also adds a few Robo extensions such as the say() and yell() output styles. This parameter may be omitted for commands that do not perofrom any output. When we run: robo hello davert \u279c Hello, davert Note: This assumes you have installed Robo by downloading the robo.phar file and copied it to a directory in your $PATH . For example, cp robo.phar ~/bin/robo . Method names in a RoboFile should be camelCased. When called from the CLI, camelCased methods will be available as commands formatted as camel:cased . longCamelCased methods will be transformed to commands formatted as long:camel-cased . Arguments All method parameters without default values are treated as required arguments. In our example command hello requires one argument. If you pass a default value to parameter the argument becomes optional: <?php function hello(ConsoleIO $io, $world = 'world') { $io->say(\"Hello, $world\"); } ?> robo hello \u279c Hello, world To accept multiple, variable arguments, typehint a parameter as an array ; Robo will then pass all CLI arguments in this variable: <?php function hello(ConsoleIO $io, array $world) { $io->say(\"Hello, \" . implode(', ', $world)); } ?> robo hello davert jon bill bob \u279c Hello, davert, jon, bill, bob Options To define command options you should define the last method parameter as an associative array where the keys define the option names and the values provide each option's default value: <?php function hello(ConsoleIO $io, $opts = ['silent' => false]) { if (!$opts['silent']) $io->say(\"Hello, world\"); } ?> robo hello \u279c Hello, world robo hello --silent A one-character shortcut can be specified for option: <?php function hello(ConsoleIO $io, $opts = ['silent|s' => false]) { if (!$opts['silent']) $io->say(\"Hello, world\"); } ?> Now command can be executed with '-s' to run in silent mode: robo hello -s The default value for options must be one of: The boolean value false , which indicates that the option takes no value; the variable will be true if the option appears on the commandline, and will be false otherwise. The boolean value true , which indicates that the variable should be true unless the option is disabled on the commandline via the flag --no-foo or --foo=0 (for $opts = ['foo' => true] ). A string containing the default value for options that may be provided a value, but are not required to. NULL for options that may be provided an optional value, but that have no default when a value is not provided. The special value InputOption::VALUE_REQUIRED, which indicates that the user must provide a value for the option whenever it is used. An empty array, which indicates that the option may appear multiple times on the command line. No other values should be used for the default value. For example, $options = ['a' => 1] is incorrect ; instead, use $options = ['a' => '1'] . Load From Other Robofile Robo can execute commands from a different RoboFile, eg. located in different directory or with a different filename. You can specify the path to another RoboFile by including the --load-from option: robo run --load-from /path/to/my/other/robofile Additional notes: The filename can be anything; it is not limited to RoboFile.php . The class name inside the file has to be the same name as the file has. The class has to be in the root namespace. Eg. Foo.php => \\Foo The internal current directory (cwd) of the PHP process will be switched to the directory where the provided RoboFile came from. Pass-Through Arguments Sometimes you need to pass arguments from your command into a task. A command line after the -- delimiter is passed as a single parameter containing all of the following arguments. Any special characters such as - will be passed into without change. <?php function ls(ConsoleIO $io, array $args) { $this->taskExec('ls')->args($args)->run(); } ?> Note: Creating tasks without a builder, e.g. $this->taskExec() as shown above, is deprecated. See the Collections documentation for the preferred way to declare tasks. robo ls -- Robo -c --all [ExecTask] running ls Robo -c --all . .. CHANGELOG.md codeception.yml composer.json composer.lock docs .git .gitignore .idea LICENSE README.md robo RoboFile.php robo.phar src tests .travis.yml vendor Help The help text for a command in a RoboFile may be provided in Doc-Block comments. An example help Doc-Block comment is shown below: <?php /** * Calculate the fibonacci sequence between two numbers. * * Graphic output will look like * +----+---+-------------+ * | | | | * | |-+-| | * |----+-+-+ | * | | | * | | | * | | | * +--------+-------------+ * * @param int $start Number to start from * @param int $steps Number of steps to perform * @param array $opts * @option $graphic Display the sequence graphically using cube * representation */ public function fibonacci(ConsoleIO $io, $start, $steps, $opts = ['graphic' => false]) { } ?> The corresponding help text produced is: robo fibonacci --help Usage: fibonacci [--graphic] start steps Arguments: start Number to start from steps Number of steps to perform Options: --graphic Display the sequence graphically using cube representation Help: Graphic output will look like +----+---+-------------+ | | | | | |-+-| | |----+-+-+ | | | | | | | | | | +--------+-------------+ Arguments and options are populated from annotations. Initially added with PR by @jonsa ; now provided by the consolidation/annotated-command project, which was factored out from Robo. Ignored methods Robo ignores any method of your RoboFile that begins with get or set . These methods are presumed to be data accessors, not commands. To implement a command whose name contains get or set , use the @command annotation. <?php /** * @command set-alignment */ function setAlignment(ConsoleIO $io, $value) { ... } ?> Tasks Robo commands typically divide the work they need to accomplish into tasks . The command first determines what needs to be done, inspecting current state if necessary, and then sets up and executes one or more tasks that make the actual changes needed by the command. (See also the documentation on Collections , which allow you to combine groups of tasks which can provide rollback functions to recover from failure situations.) For details on how to add custom tasks to Robo, see the extending document. Shortcuts Some tasks may have shortcuts. If a task does not require multi-step configuration, it can be executed with a single line: <?php $this->_exec('ps aux'); $this->_copy('config/env.example.yml','config/env.yml'); ?> Result Each task must return an instance of Robo\\Result . A Robo Result contains the task instance, exit code, message, and any variable data that the task may wish to return. Note : A task may also return NULL or an array as a shortcut for a successful result. In this instance, Robo will convert the value into a Robo\\Result , and will apply the provided array values, if any, to the result's variable data. This practice is supported, but not recommended. The run method of CompileAssets class may look like this: return new Robo\\Result($this, $exitCode, \"Assets compiled\"); or return Robo\\Result::success($this, \"Assets compiled\"); return Robo\\Result::error($this, \"Failed to compile assets\"); You can use this results to check if execution was successful, either using the wasSuccessful() method, or via the invoke shortcut. We will use the Exec task in next example to illustrate this: <?php class RoboFile { use Robo\\Task\\Base\\loadShortcuts; function test(ConsoleIO $io) { $res1 = $this->_exec('phpunit tests/integration'); $res2 = $this->_exec('phpunit tests/unit'); // print message when tests passed if ($res1->wasSuccessful() and $res2->wasSuccessful()) $io->say(\"All tests passed\"); } } ?> When making multi-step commands that call one task after another, it is best to use a collection to group the tasks together. The collection will handle error detection and rollback, and will return a single Result object when done. For more information, see the Collections documentation. Some tasks may also attach data to the Result object. If this is done, the data may be accessed as an array; for example, $result['path']; . This is not common. Commands should return a Result object obtained from a task; this will ensure that the command exit code is set correctly. If a command does not have a Result object available, then it may use a ResultData object. ResultData objects are just like Result objects, except the do not contain a reference to a task. return new Robo\\ResultData($exitcode, 'Error message.'); If the command returns a TaskInterface instead of a result, then the task will be executed, and the result from that task will be used as the final result of the command. See also Formatters , below. Stack Some tasks contain Stack in their name. These are called \"stack\" tasks, and they execute similar tasks one after the other. Each of the primary methods in a stack class executes an operation. Stack tasks also contain a stopOnFail method which can be used to stop task execution if one of its commands was unsuccessful. Global StopOnFail There is a global stopOnFail method as well, that can be used to stop a command on first failure of a task. $this->stopOnFail(true); Note, however, that using Collections is preferred. Progress Robo supports progress indicators via the Symfony ProgressBar class. Long-running tasks that wish to display the progress indicator may do so via four simple steps: Override the progressIndicatorSteps() method and return the number of \"steps\" in the operation. Call $this->startProgressIndicator() to begin the progress indicator running. Call $this->advanceProgressIndicator() a number of times equal to the result returned by progressIndicatorSteps() Call $this->stopProgressIndicator() when the operation is completed. An example of this is shown below: <?php class MyTask extends BaseTask { protected $steps = 10; public function progressIndicatorSteps() { return $this->steps; } public function run() { $exitCode = 0; $errorMessage = \"\"; $this->startProgressIndicator(); for ($i = 0; $i < $this->steps; ++$i) { $this->advanceProgressIndicator(); } $this->stopProgressIndicator(); return new Result($this, $exitCode, $errorMessage, ['time' => $this->getExecutionTime()]); } } ?> Tasks should not attempt to use a specific progress indicator (e.g. the Symfony ProgressBar class) directly, as the ProgressIndicatorAwareTrait allows for an appropriate progress indicator to be used (or omitted) as best suits the application. Note that when using Collections , the progress bar will automatically be shown if the collection takes longer than two seconds to run. Each task in the collection will count for one \"step\"; if the task supports progress indicators as shown above, then it will add an additional number of steps as indicated by its progressIndicatorSteps() method. Configuration On startup, Robo will load a configuration file, robo.yml , if it exists in the current working directory, or in the directory $HOME/.robo/robo.yml, or at the path set by the ROBO_CONFIG environment variable. If both the user's robo.yml file and a robo.yml in the current working directory exist, then both will be loaded, with values from the configuration file in the current working directory taking precedence over the values in the user's configuration file. Environment variables can also be used to set individual configuration values. The environment variable key should start with the string ROBO_ , and should be followed by an all-uppercase version of the configuration key, with spaces, dashes and dots converted to underscores. For example, to set the progress bar delay to 999999 seconds: export ROBO_OPTIONS_PROGRESS_DELAY=999999 Configuration values may also be set via the -D commandline switch. The above effect can also be achieved by adding -Doptions.progress-delay=999999 to any Robo command. Configuration for Command Options The preferred method for commands to use to read configuration is to simply define commandline options for each configuration value. Configuration may be provided for any command option in the robo.yml configuration file. For example, given the following Robo command: <?php function hello(ConsoleIO $io, $opts = ['who' => 'unknown']) { $io->say(\"Hello, \" . $opts['who']); } ?> The who option can be defined as follows: command: hello: options: who: world If you run this command, then it will print Hello, world . If the --who option is provided on the command line, that value will take precidence over the value stored in configuration. Thus, hello --who=everyone will print Hello, everyone . Command groups may also share configuration options. For example, if you have commands foo:bar , foo:baz and foo:boz , all of which share a common option color , then the following configuration will provide the value blue to foo:bar and foo:baz , and the value green to foo:boz : command: foo: options: color: blue boz: options: color: green Configuration for Task Settings Robo will automatically configure tasks with values from configuration. For example, given the following task definition: $this->taskMyOperation() ->dir($buildDir) ->extrapolated(false) ->run(); You could instead remove the setter methods and move the parameter values to a configruation file: $this->taskComposerInstall() ->run(); Then, presuming that taskMyOperation was implemented in a class \\MyOrg\\Task\\TaskGroup\\MyOperation , then the corresponding configuration file would appear as follows: task: TaskGroup: MyOperation: settings: dir: /my/path extrapolated: false The key for configuration-injected settings is task.PARTIAL_NAMESPACE.CLASSNAME.settings.key . PARTIAL_NAMESPACE is the namespace for the class, with each \\ replaced with a . , and with each component of the namespace up to and including Task removed. Tasks in the same namespace may also share configuration-injected settings. For example, the configuration below will set the dir option of any task implemented by a class in the *\\TaskGroup\\MyOperation namespace, unless the task has a more specific configuration value stored with its classname: task: TaskGroup: settings: dir: /my/path extrapolated: false Accessing Configuration Directly In a RoboFile, use \\Robo\\Robo::Config()->get('task.TaskGroup.MyOperation.settings.dir'); to fetch the dir configuration option from the previous example. In the implementation of taskMyOperation() itself, it is in general not necessary to access configuration values directly, as it is preferable to allow Robo to inject configuration as described above. However, if desired, configuration may be accessed from within the method of any task that extends \\Robo\\Task\\BaseTask (or otherwise uses ConfigAwareTrait ) may do so via static::getConfigValue('key', 'default'); . Providing Default Configuration in Code RoboFiles that wish to provide default configuration values that can be overridden via robo.yml values or commandline options may do so in the class' constructor method. The example below demonstrates how to set up a default value for the task.Ssh.remoteDir configuration property in code: class RoboFile { public function __construct() { Robo\\Task\\Remote\\Ssh::configure('remoteDir', '/srv/www'); } } If task.Remote.Ssh.remoteDir is set to some other value in the robo.yml configuration file in the current directory, then the value from the configuration file will take precedence. Loading Configuration From Another Source Sometimes, a RoboFile might want to define its own private configuration file to use in addition to the standard robo.yml file. This can also be done in the constructor. class RoboFile { public function __construct() { Robo::loadConfiguration([__DIR__ . '/myconf.yml']); } } Note that configuration loaded in this way will take precedence over the configuration loaded by default by Robo. It is possible to have even more control than this if you create your own application using Robo as a Framework . IO As you noticed, you can print text via the say method, which is taken from the Robo\\Output trait. $this->say(\"Hello\"); Also, you can ask for input from console: $name = $this->ask(\"What is your name?\"); There are also askDefault , askHidden , and confirm methods. In addition, Robo makes all of the methods of Symfony Style available through the io() method: $this->io()->title(\"Build all site assets\"); This allows Robo scripts to follow the documentation on How to Style a Console Command if desired. Formatters It is preferable for commands that look up and display information should avoid doing IO directly, and should instead return the data they wish to display as an array. This data can then be converted into different data formats, such as \"table\" and \"json\". The user may select which formatter to use via the --format option. For details on formatters, see the consolidation/output-formatters project. Working with Composer Adding a RoboFile to your Project Robo is designed to work well with Composer. To use Robo scripts in your Composer-based project, simply add robo to your composer.json file: $ cd myproject $ composer require consolidation/robo:^2 $ ./vendor/bin/robo mycommand If you do not want to type the whole path to Robo, you may add ./vendor/bin to your $PATH (relative paths work), or use composer exec to find and run Robo: $ composer exec robo mycommand Implementing Composer Scripts with Robo When using Robo in your project, it is convenient to define Composer scripts that call your Robo commands. Simply add the following to your composer.json file: { \"name\": \"myorg/myproject\", \"require\": { \"consolidation/robo\": \"^2\" }, \"scripts\": { \"test\": \"composer robo test\", \"phar\": \"composer robo phar:build\", \"robo\": \"robo --ansi --load-from $(pwd)/scripts/BuildCommands.php\" } } Note : When you include Robo as a library like this, some external projects used by certain core Robo tasks are not automatically included in your project. See the \"suggest\": section of Robo's composer.json for a list of external projects you might also want to require in your project. Once you have set up your composer.json file (and ran composer update if you manually changed the require or require-dev sections), Composer will ensure that your project-local copy of Robo in the vendor/bin dir is in your $PATH when you run the additional Composer scripts that you declared: $ cd myproject $ composer test $ composer phar This will call the public methods test() and phar() in your RoboFile.php when using composer test and composer phar , respectively. Advertising your build commands as Composer scripts is a useful way to provide the key commands used for testing, building or packaging your application. Also, if your application should happen to provide a commandline tool to perform the operations of the application itself, then defining your build commands in their own RoboFile provides desirable separation, keeping your build commands out of the help and list commands of your primary script. If you would like to simplify the output of your script (e.g. when running on a CI service), replace the --ansi option in the example above with --no-ansi , and colored terminal output and progress bars will be disabled. Robo as a Framework For an overview on how to turn your Robo scripts into standalone tools, see the example robo.script , and the section Robo as a Framework .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"To begin you need to create a RoboFile. Just run robo init in your project directory: cd myproject robo init Your project directory may start out empty; Robo will create a new RoboFile.php for you. There will be RoboFile class which extends \\Robo\\Tasks , which includes all bundled tasks of Robo. <?php class RoboFile extends \\Robo\\Tasks { } ?>","title":"Getting Started"},{"location":"getting-started/#commands","text":"All public methods of the RoboFile class will be treated as commands . You can run them from the CLI and pass arguments. <?php use Robo\\Symfony\\ConsoleIO; class RoboFile extends \\Robo\\Tasks { function hello(ConsoleIO $io, $world) { $io->say(\"Hello, $world\"); } } ?> Note: The class ConsoleIO isa SymfonyStyle, and therefore has access to all of the Symfony styling methods. It also adds a few Robo extensions such as the say() and yell() output styles. This parameter may be omitted for commands that do not perofrom any output. When we run: robo hello davert \u279c Hello, davert Note: This assumes you have installed Robo by downloading the robo.phar file and copied it to a directory in your $PATH . For example, cp robo.phar ~/bin/robo . Method names in a RoboFile should be camelCased. When called from the CLI, camelCased methods will be available as commands formatted as camel:cased . longCamelCased methods will be transformed to commands formatted as long:camel-cased .","title":"Commands"},{"location":"getting-started/#arguments","text":"All method parameters without default values are treated as required arguments. In our example command hello requires one argument. If you pass a default value to parameter the argument becomes optional: <?php function hello(ConsoleIO $io, $world = 'world') { $io->say(\"Hello, $world\"); } ?> robo hello \u279c Hello, world To accept multiple, variable arguments, typehint a parameter as an array ; Robo will then pass all CLI arguments in this variable: <?php function hello(ConsoleIO $io, array $world) { $io->say(\"Hello, \" . implode(', ', $world)); } ?> robo hello davert jon bill bob \u279c Hello, davert, jon, bill, bob","title":"Arguments"},{"location":"getting-started/#options","text":"To define command options you should define the last method parameter as an associative array where the keys define the option names and the values provide each option's default value: <?php function hello(ConsoleIO $io, $opts = ['silent' => false]) { if (!$opts['silent']) $io->say(\"Hello, world\"); } ?> robo hello \u279c Hello, world robo hello --silent A one-character shortcut can be specified for option: <?php function hello(ConsoleIO $io, $opts = ['silent|s' => false]) { if (!$opts['silent']) $io->say(\"Hello, world\"); } ?> Now command can be executed with '-s' to run in silent mode: robo hello -s The default value for options must be one of: The boolean value false , which indicates that the option takes no value; the variable will be true if the option appears on the commandline, and will be false otherwise. The boolean value true , which indicates that the variable should be true unless the option is disabled on the commandline via the flag --no-foo or --foo=0 (for $opts = ['foo' => true] ). A string containing the default value for options that may be provided a value, but are not required to. NULL for options that may be provided an optional value, but that have no default when a value is not provided. The special value InputOption::VALUE_REQUIRED, which indicates that the user must provide a value for the option whenever it is used. An empty array, which indicates that the option may appear multiple times on the command line. No other values should be used for the default value. For example, $options = ['a' => 1] is incorrect ; instead, use $options = ['a' => '1'] .","title":"Options"},{"location":"getting-started/#load-from-other-robofile","text":"Robo can execute commands from a different RoboFile, eg. located in different directory or with a different filename. You can specify the path to another RoboFile by including the --load-from option: robo run --load-from /path/to/my/other/robofile Additional notes: The filename can be anything; it is not limited to RoboFile.php . The class name inside the file has to be the same name as the file has. The class has to be in the root namespace. Eg. Foo.php => \\Foo The internal current directory (cwd) of the PHP process will be switched to the directory where the provided RoboFile came from.","title":"Load From Other Robofile"},{"location":"getting-started/#pass-through-arguments","text":"Sometimes you need to pass arguments from your command into a task. A command line after the -- delimiter is passed as a single parameter containing all of the following arguments. Any special characters such as - will be passed into without change. <?php function ls(ConsoleIO $io, array $args) { $this->taskExec('ls')->args($args)->run(); } ?> Note: Creating tasks without a builder, e.g. $this->taskExec() as shown above, is deprecated. See the Collections documentation for the preferred way to declare tasks. robo ls -- Robo -c --all [ExecTask] running ls Robo -c --all . .. CHANGELOG.md codeception.yml composer.json composer.lock docs .git .gitignore .idea LICENSE README.md robo RoboFile.php robo.phar src tests .travis.yml vendor","title":"Pass-Through Arguments"},{"location":"getting-started/#help","text":"The help text for a command in a RoboFile may be provided in Doc-Block comments. An example help Doc-Block comment is shown below: <?php /** * Calculate the fibonacci sequence between two numbers. * * Graphic output will look like * +----+---+-------------+ * | | | | * | |-+-| | * |----+-+-+ | * | | | * | | | * | | | * +--------+-------------+ * * @param int $start Number to start from * @param int $steps Number of steps to perform * @param array $opts * @option $graphic Display the sequence graphically using cube * representation */ public function fibonacci(ConsoleIO $io, $start, $steps, $opts = ['graphic' => false]) { } ?> The corresponding help text produced is: robo fibonacci --help Usage: fibonacci [--graphic] start steps Arguments: start Number to start from steps Number of steps to perform Options: --graphic Display the sequence graphically using cube representation Help: Graphic output will look like +----+---+-------------+ | | | | | |-+-| | |----+-+-+ | | | | | | | | | | +--------+-------------+ Arguments and options are populated from annotations. Initially added with PR by @jonsa ; now provided by the consolidation/annotated-command project, which was factored out from Robo.","title":"Help"},{"location":"getting-started/#ignored-methods","text":"Robo ignores any method of your RoboFile that begins with get or set . These methods are presumed to be data accessors, not commands. To implement a command whose name contains get or set , use the @command annotation. <?php /** * @command set-alignment */ function setAlignment(ConsoleIO $io, $value) { ... } ?>","title":"Ignored methods"},{"location":"getting-started/#tasks","text":"Robo commands typically divide the work they need to accomplish into tasks . The command first determines what needs to be done, inspecting current state if necessary, and then sets up and executes one or more tasks that make the actual changes needed by the command. (See also the documentation on Collections , which allow you to combine groups of tasks which can provide rollback functions to recover from failure situations.) For details on how to add custom tasks to Robo, see the extending document.","title":"Tasks"},{"location":"getting-started/#shortcuts","text":"Some tasks may have shortcuts. If a task does not require multi-step configuration, it can be executed with a single line: <?php $this->_exec('ps aux'); $this->_copy('config/env.example.yml','config/env.yml'); ?>","title":"Shortcuts"},{"location":"getting-started/#result","text":"Each task must return an instance of Robo\\Result . A Robo Result contains the task instance, exit code, message, and any variable data that the task may wish to return. Note : A task may also return NULL or an array as a shortcut for a successful result. In this instance, Robo will convert the value into a Robo\\Result , and will apply the provided array values, if any, to the result's variable data. This practice is supported, but not recommended. The run method of CompileAssets class may look like this: return new Robo\\Result($this, $exitCode, \"Assets compiled\"); or return Robo\\Result::success($this, \"Assets compiled\"); return Robo\\Result::error($this, \"Failed to compile assets\"); You can use this results to check if execution was successful, either using the wasSuccessful() method, or via the invoke shortcut. We will use the Exec task in next example to illustrate this: <?php class RoboFile { use Robo\\Task\\Base\\loadShortcuts; function test(ConsoleIO $io) { $res1 = $this->_exec('phpunit tests/integration'); $res2 = $this->_exec('phpunit tests/unit'); // print message when tests passed if ($res1->wasSuccessful() and $res2->wasSuccessful()) $io->say(\"All tests passed\"); } } ?> When making multi-step commands that call one task after another, it is best to use a collection to group the tasks together. The collection will handle error detection and rollback, and will return a single Result object when done. For more information, see the Collections documentation. Some tasks may also attach data to the Result object. If this is done, the data may be accessed as an array; for example, $result['path']; . This is not common. Commands should return a Result object obtained from a task; this will ensure that the command exit code is set correctly. If a command does not have a Result object available, then it may use a ResultData object. ResultData objects are just like Result objects, except the do not contain a reference to a task. return new Robo\\ResultData($exitcode, 'Error message.'); If the command returns a TaskInterface instead of a result, then the task will be executed, and the result from that task will be used as the final result of the command. See also Formatters , below.","title":"Result"},{"location":"getting-started/#stack","text":"Some tasks contain Stack in their name. These are called \"stack\" tasks, and they execute similar tasks one after the other. Each of the primary methods in a stack class executes an operation. Stack tasks also contain a stopOnFail method which can be used to stop task execution if one of its commands was unsuccessful.","title":"Stack"},{"location":"getting-started/#global-stoponfail","text":"There is a global stopOnFail method as well, that can be used to stop a command on first failure of a task. $this->stopOnFail(true); Note, however, that using Collections is preferred.","title":"Global StopOnFail"},{"location":"getting-started/#progress","text":"Robo supports progress indicators via the Symfony ProgressBar class. Long-running tasks that wish to display the progress indicator may do so via four simple steps: Override the progressIndicatorSteps() method and return the number of \"steps\" in the operation. Call $this->startProgressIndicator() to begin the progress indicator running. Call $this->advanceProgressIndicator() a number of times equal to the result returned by progressIndicatorSteps() Call $this->stopProgressIndicator() when the operation is completed. An example of this is shown below: <?php class MyTask extends BaseTask { protected $steps = 10; public function progressIndicatorSteps() { return $this->steps; } public function run() { $exitCode = 0; $errorMessage = \"\"; $this->startProgressIndicator(); for ($i = 0; $i < $this->steps; ++$i) { $this->advanceProgressIndicator(); } $this->stopProgressIndicator(); return new Result($this, $exitCode, $errorMessage, ['time' => $this->getExecutionTime()]); } } ?> Tasks should not attempt to use a specific progress indicator (e.g. the Symfony ProgressBar class) directly, as the ProgressIndicatorAwareTrait allows for an appropriate progress indicator to be used (or omitted) as best suits the application. Note that when using Collections , the progress bar will automatically be shown if the collection takes longer than two seconds to run. Each task in the collection will count for one \"step\"; if the task supports progress indicators as shown above, then it will add an additional number of steps as indicated by its progressIndicatorSteps() method.","title":"Progress"},{"location":"getting-started/#configuration","text":"On startup, Robo will load a configuration file, robo.yml , if it exists in the current working directory, or in the directory $HOME/.robo/robo.yml, or at the path set by the ROBO_CONFIG environment variable. If both the user's robo.yml file and a robo.yml in the current working directory exist, then both will be loaded, with values from the configuration file in the current working directory taking precedence over the values in the user's configuration file. Environment variables can also be used to set individual configuration values. The environment variable key should start with the string ROBO_ , and should be followed by an all-uppercase version of the configuration key, with spaces, dashes and dots converted to underscores. For example, to set the progress bar delay to 999999 seconds: export ROBO_OPTIONS_PROGRESS_DELAY=999999 Configuration values may also be set via the -D commandline switch. The above effect can also be achieved by adding -Doptions.progress-delay=999999 to any Robo command.","title":"Configuration"},{"location":"getting-started/#configuration-for-command-options","text":"The preferred method for commands to use to read configuration is to simply define commandline options for each configuration value. Configuration may be provided for any command option in the robo.yml configuration file. For example, given the following Robo command: <?php function hello(ConsoleIO $io, $opts = ['who' => 'unknown']) { $io->say(\"Hello, \" . $opts['who']); } ?> The who option can be defined as follows: command: hello: options: who: world If you run this command, then it will print Hello, world . If the --who option is provided on the command line, that value will take precidence over the value stored in configuration. Thus, hello --who=everyone will print Hello, everyone . Command groups may also share configuration options. For example, if you have commands foo:bar , foo:baz and foo:boz , all of which share a common option color , then the following configuration will provide the value blue to foo:bar and foo:baz , and the value green to foo:boz : command: foo: options: color: blue boz: options: color: green","title":"Configuration for Command Options"},{"location":"getting-started/#configuration-for-task-settings","text":"Robo will automatically configure tasks with values from configuration. For example, given the following task definition: $this->taskMyOperation() ->dir($buildDir) ->extrapolated(false) ->run(); You could instead remove the setter methods and move the parameter values to a configruation file: $this->taskComposerInstall() ->run(); Then, presuming that taskMyOperation was implemented in a class \\MyOrg\\Task\\TaskGroup\\MyOperation , then the corresponding configuration file would appear as follows: task: TaskGroup: MyOperation: settings: dir: /my/path extrapolated: false The key for configuration-injected settings is task.PARTIAL_NAMESPACE.CLASSNAME.settings.key . PARTIAL_NAMESPACE is the namespace for the class, with each \\ replaced with a . , and with each component of the namespace up to and including Task removed. Tasks in the same namespace may also share configuration-injected settings. For example, the configuration below will set the dir option of any task implemented by a class in the *\\TaskGroup\\MyOperation namespace, unless the task has a more specific configuration value stored with its classname: task: TaskGroup: settings: dir: /my/path extrapolated: false","title":"Configuration for Task Settings"},{"location":"getting-started/#accessing-configuration-directly","text":"In a RoboFile, use \\Robo\\Robo::Config()->get('task.TaskGroup.MyOperation.settings.dir'); to fetch the dir configuration option from the previous example. In the implementation of taskMyOperation() itself, it is in general not necessary to access configuration values directly, as it is preferable to allow Robo to inject configuration as described above. However, if desired, configuration may be accessed from within the method of any task that extends \\Robo\\Task\\BaseTask (or otherwise uses ConfigAwareTrait ) may do so via static::getConfigValue('key', 'default'); .","title":"Accessing Configuration Directly"},{"location":"getting-started/#providing-default-configuration-in-code","text":"RoboFiles that wish to provide default configuration values that can be overridden via robo.yml values or commandline options may do so in the class' constructor method. The example below demonstrates how to set up a default value for the task.Ssh.remoteDir configuration property in code: class RoboFile { public function __construct() { Robo\\Task\\Remote\\Ssh::configure('remoteDir', '/srv/www'); } } If task.Remote.Ssh.remoteDir is set to some other value in the robo.yml configuration file in the current directory, then the value from the configuration file will take precedence.","title":"Providing Default Configuration in Code"},{"location":"getting-started/#loading-configuration-from-another-source","text":"Sometimes, a RoboFile might want to define its own private configuration file to use in addition to the standard robo.yml file. This can also be done in the constructor. class RoboFile { public function __construct() { Robo::loadConfiguration([__DIR__ . '/myconf.yml']); } } Note that configuration loaded in this way will take precedence over the configuration loaded by default by Robo. It is possible to have even more control than this if you create your own application using Robo as a Framework .","title":"Loading Configuration From Another Source"},{"location":"getting-started/#io","text":"As you noticed, you can print text via the say method, which is taken from the Robo\\Output trait. $this->say(\"Hello\"); Also, you can ask for input from console: $name = $this->ask(\"What is your name?\"); There are also askDefault , askHidden , and confirm methods. In addition, Robo makes all of the methods of Symfony Style available through the io() method: $this->io()->title(\"Build all site assets\"); This allows Robo scripts to follow the documentation on How to Style a Console Command if desired.","title":"IO"},{"location":"getting-started/#formatters","text":"It is preferable for commands that look up and display information should avoid doing IO directly, and should instead return the data they wish to display as an array. This data can then be converted into different data formats, such as \"table\" and \"json\". The user may select which formatter to use via the --format option. For details on formatters, see the consolidation/output-formatters project.","title":"Formatters"},{"location":"getting-started/#working-with-composer","text":"","title":"Working with Composer"},{"location":"getting-started/#adding-a-robofile-to-your-project","text":"Robo is designed to work well with Composer. To use Robo scripts in your Composer-based project, simply add robo to your composer.json file: $ cd myproject $ composer require consolidation/robo:^2 $ ./vendor/bin/robo mycommand If you do not want to type the whole path to Robo, you may add ./vendor/bin to your $PATH (relative paths work), or use composer exec to find and run Robo: $ composer exec robo mycommand","title":"Adding a RoboFile to your Project"},{"location":"getting-started/#implementing-composer-scripts-with-robo","text":"When using Robo in your project, it is convenient to define Composer scripts that call your Robo commands. Simply add the following to your composer.json file: { \"name\": \"myorg/myproject\", \"require\": { \"consolidation/robo\": \"^2\" }, \"scripts\": { \"test\": \"composer robo test\", \"phar\": \"composer robo phar:build\", \"robo\": \"robo --ansi --load-from $(pwd)/scripts/BuildCommands.php\" } } Note : When you include Robo as a library like this, some external projects used by certain core Robo tasks are not automatically included in your project. See the \"suggest\": section of Robo's composer.json for a list of external projects you might also want to require in your project. Once you have set up your composer.json file (and ran composer update if you manually changed the require or require-dev sections), Composer will ensure that your project-local copy of Robo in the vendor/bin dir is in your $PATH when you run the additional Composer scripts that you declared: $ cd myproject $ composer test $ composer phar This will call the public methods test() and phar() in your RoboFile.php when using composer test and composer phar , respectively. Advertising your build commands as Composer scripts is a useful way to provide the key commands used for testing, building or packaging your application. Also, if your application should happen to provide a commandline tool to perform the operations of the application itself, then defining your build commands in their own RoboFile provides desirable separation, keeping your build commands out of the help and list commands of your primary script. If you would like to simplify the output of your script (e.g. when running on a CI service), replace the --ansi option in the example above with --no-ansi , and colored terminal output and progress bars will be disabled.","title":"Implementing Composer Scripts with Robo"},{"location":"getting-started/#robo-as-a-framework","text":"For an overview on how to turn your Robo scripts into standalone tools, see the example robo.script , and the section Robo as a Framework .","title":"Robo as a Framework"},{"location":"tasks/ApiGen/","text":"ApiGen Tasks ApiGen Executes ApiGen command to generate documentation <?php // ApiGen Command $this->taskApiGen('./vendor/apigen/apigen.phar') ->config('./apigen.neon') ->templateConfig('vendor/apigen/apigen/templates/bootstrap/config.neon') ->wipeout(true) ->run(); ?> args($args) Pass methods parameters as arguments to executable. Argument values config($config) * param string $config source($src) * param array|string|\\Traversable $src destination($dest) * param string $dest extensions($exts) * param array|string $exts exclude($exclude) * param array|string $exclude skipDocPath($path) * param array|string|\\Traversable $path skipDocPrefix($prefix) * param array|string|\\Traversable $prefix charset($charset) * param array|string $charset mainProjectNamePrefix($name) * param string $name title($title) * param string $title baseUrl($baseUrl) * param string $baseUrl googleCseId($id) * param string $id googleAnalytics($trackingCode) * param string $trackingCode templateConfig($templateConfig) * param mixed $templateConfig allowedHtml($tags) * param array|string $tags groups($groups) * param string $groups autocomplete($types) * param array|string $types accessLevels($levels) * param array|string $levels internal($internal) * param boolean|string $internal php($php) * param bool|string $php tree($tree) * param bool|string $tree deprecated($dep) * param bool|string $dep todo($todo) * param bool|string $todo sourceCode($src) * param bool|string $src download($zipped) * param bool|string $zipped report($path) * param string $path wipeout($wipeout) * param bool|string $wipeout quiet($quiet) * param bool|string $quiet progressbar($bar) * param bool|string $bar colors($colors) * param bool|string $colors updateCheck($check) * param bool|string $check debug($debug) * param bool|string $debug setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"ApiGen Tasks"},{"location":"tasks/ApiGen/#apigen-tasks","text":"","title":"ApiGen Tasks"},{"location":"tasks/ApiGen/#apigen","text":"Executes ApiGen command to generate documentation <?php // ApiGen Command $this->taskApiGen('./vendor/apigen/apigen.phar') ->config('./apigen.neon') ->templateConfig('vendor/apigen/apigen/templates/bootstrap/config.neon') ->wipeout(true) ->run(); ?> args($args) Pass methods parameters as arguments to executable. Argument values config($config) * param string $config source($src) * param array|string|\\Traversable $src destination($dest) * param string $dest extensions($exts) * param array|string $exts exclude($exclude) * param array|string $exclude skipDocPath($path) * param array|string|\\Traversable $path skipDocPrefix($prefix) * param array|string|\\Traversable $prefix charset($charset) * param array|string $charset mainProjectNamePrefix($name) * param string $name title($title) * param string $title baseUrl($baseUrl) * param string $baseUrl googleCseId($id) * param string $id googleAnalytics($trackingCode) * param string $trackingCode templateConfig($templateConfig) * param mixed $templateConfig allowedHtml($tags) * param array|string $tags groups($groups) * param string $groups autocomplete($types) * param array|string $types accessLevels($levels) * param array|string $levels internal($internal) * param boolean|string $internal php($php) * param bool|string $php tree($tree) * param bool|string $tree deprecated($dep) * param bool|string $dep todo($todo) * param bool|string $todo sourceCode($src) * param bool|string $src download($zipped) * param bool|string $zipped report($path) * param string $path wipeout($wipeout) * param bool|string $wipeout quiet($quiet) * param bool|string $quiet progressbar($bar) * param bool|string $bar colors($colors) * param bool|string $colors updateCheck($check) * param bool|string $check debug($debug) * param bool|string $debug setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"ApiGen"},{"location":"tasks/Archive/","text":"Archive Tasks Extract Extracts an archive. Note that often, distributions are packaged in tar or zip archives where the topmost folder may contain variable information, such as the release date, or the version of the package. This information is very useful when unpacking by hand, but arbitrarily-named directories are much less useful to scripts. Therefore, by default, Extract will remove the top-level directory, and instead store all extracted files into the directory specified by $archivePath. To keep the top-level directory when extracting, use preserveTopDirectory(true) . <?php $this->taskExtract($archivePath) ->to($destination) ->preserveTopDirectory(false) // the default ->run(); ?> to($to) Location to store extracted files. preserveTopDirectory($preserve = null) * param bool $preserve setOutput($output) Sets the Console Output. Pack Creates a zip or tar archive. <?php $this->taskPack( <archiveFile>) ->add('README') // Puts file 'README' in archive at the root ->add('project') // Puts entire contents of directory 'project' in archinve inside 'project' ->addFile('dir/file.txt', 'file.txt') // Takes 'file.txt' from cwd and puts it in archive inside 'dir'. ->exclude(['dir\\/.*.zip', '.*.md']) // Add regex (or array of regex) to the excluded patterns list. ->run(); ?> archiveFile($archiveFile) * param string $archiveFile addFile($placementLocation, $filesystemLocation) Add an item to the archive. Like file_exists(), the parameter addDir($placementLocation, $filesystemLocation) Alias for addFile, in case anyone has angst about using add($item) Add a file or directory, or list of same to the archive. exclude($ignoreList) Allow files or folder to be excluded from the archive. Use regex, without enclosing slashes. setOutput($output) Sets the Console Output.","title":"Archive Tasks"},{"location":"tasks/Archive/#archive-tasks","text":"","title":"Archive Tasks"},{"location":"tasks/Archive/#extract","text":"Extracts an archive. Note that often, distributions are packaged in tar or zip archives where the topmost folder may contain variable information, such as the release date, or the version of the package. This information is very useful when unpacking by hand, but arbitrarily-named directories are much less useful to scripts. Therefore, by default, Extract will remove the top-level directory, and instead store all extracted files into the directory specified by $archivePath. To keep the top-level directory when extracting, use preserveTopDirectory(true) . <?php $this->taskExtract($archivePath) ->to($destination) ->preserveTopDirectory(false) // the default ->run(); ?> to($to) Location to store extracted files. preserveTopDirectory($preserve = null) * param bool $preserve setOutput($output) Sets the Console Output.","title":"Extract"},{"location":"tasks/Archive/#pack","text":"Creates a zip or tar archive. <?php $this->taskPack( <archiveFile>) ->add('README') // Puts file 'README' in archive at the root ->add('project') // Puts entire contents of directory 'project' in archinve inside 'project' ->addFile('dir/file.txt', 'file.txt') // Takes 'file.txt' from cwd and puts it in archive inside 'dir'. ->exclude(['dir\\/.*.zip', '.*.md']) // Add regex (or array of regex) to the excluded patterns list. ->run(); ?> archiveFile($archiveFile) * param string $archiveFile addFile($placementLocation, $filesystemLocation) Add an item to the archive. Like file_exists(), the parameter addDir($placementLocation, $filesystemLocation) Alias for addFile, in case anyone has angst about using add($item) Add a file or directory, or list of same to the archive. exclude($ignoreList) Allow files or folder to be excluded from the archive. Use regex, without enclosing slashes. setOutput($output) Sets the Console Output.","title":"Pack"},{"location":"tasks/Assets/","text":"Assets Tasks ImageMinify Minifies images. When the required minifier is not installed on the system the task will try to download it from the imagemin repository. When the task is run without any specified minifier it will compress the images based on the extension. $this->taskImageMinify('assets/images/*') ->to('dist/images/') ->run(); This will use the following minifiers: PNG: optipng GIF: gifsicle JPG, JPEG: jpegtran SVG: svgo When the minifier is specified the task will use that for all the input files. In that case it is useful to filter the files with the extension: $this->taskImageMinify('assets/images/*.png') ->to('dist/images/') ->minifier('pngcrush'); ->run(); The task supports the following minifiers: optipng pngquant advpng pngout zopflipng pngcrush gifsicle jpegoptim jpeg-recompress jpegtran svgo (only minification, no downloading) You can also specifiy extra options for the minifiers: $this->taskImageMinify('assets/images/*.jpg') ->to('dist/images/') ->minifier('jpegtran', ['-progressive' => null, '-copy' => 'none']) ->run(); This will execute as: jpegtran -copy none -progressive -optimize -outfile \"dist/images/test.jpg\" \"/var/www/test/assets/images/test.jpg\" to($target) Sets the target directory where the files will be copied to. minifier($minifier, array $options = Array ( ) ) Sets the minifier. setOutput($output) Sets the Console Output. Less Compiles less files. <?php $this->taskLess([ 'less/default.less' => 'css/default.css' ]) ->run(); ?> Use one of both less compilers in your project: \"leafo/lessphp\": \"~0.5\", \"oyejorge/less.php\": \"~1.5\" Specify directory (string or array) for less imports lookup: <?php $this->taskLess([ 'less/default.less' => 'css/default.css' ]) ->importDir('less') ->compiler('lessphp') ->run(); ?> You can implement additional compilers by extending this task and adding a method named after them and overloading the lessCompilers() method to inject the name there. importDir($dirs) Sets import directories addImportPath($dir) Adds import directory setImportPaths($dirs) Sets import directories setFormatter($formatterName) * param string $formatterName compiler($compiler, array $options = Array ( ) ) Sets the compiler. setOutput($output) Sets the Console Output. Minify Minifies an asset file (CSS or JS). <?php $this->taskMinify('web/assets/theme.css') ->run() ?> Please install additional packages to use this task: composer require patchwork/jsqueeze:^2.0 composer require natxet/cssmin:^3.0 to($dst) Sets destination. Tries to guess type from it. type($type) Sets type with validation. singleLine($singleLine) Single line option for the JS minimisation. keepImportantComments($keepImportantComments) keepImportantComments option for the JS minimisation. specialVarRx($specialVarRx) Set specialVarRx option for the JS minimisation. __toString() @return string setOutput($output) Sets the Console Output. Scss Compiles scss files. <?php $this->taskScss([ 'scss/default.scss' => 'css/default.css' ]) ->importDir('assets/styles') ->run(); ?> Use the following scss compiler in your project: \"scssphp/scssphp \": \"~1.0.0\", You can implement additional compilers by extending this task and adding a method named after them and overloading the scssCompilers() method to inject the name there. setFormatter($formatterName) Sets the formatter for scssphp importDir($dirs) Sets import directories addImportPath($dir) Adds import directory setImportPaths($dirs) Sets import directories compiler($compiler, array $options = Array ( ) ) Sets the compiler. setOutput($output) Sets the Console Output.","title":"Assets Tasks"},{"location":"tasks/Assets/#assets-tasks","text":"","title":"Assets Tasks"},{"location":"tasks/Assets/#imageminify","text":"Minifies images. When the required minifier is not installed on the system the task will try to download it from the imagemin repository. When the task is run without any specified minifier it will compress the images based on the extension. $this->taskImageMinify('assets/images/*') ->to('dist/images/') ->run(); This will use the following minifiers: PNG: optipng GIF: gifsicle JPG, JPEG: jpegtran SVG: svgo When the minifier is specified the task will use that for all the input files. In that case it is useful to filter the files with the extension: $this->taskImageMinify('assets/images/*.png') ->to('dist/images/') ->minifier('pngcrush'); ->run(); The task supports the following minifiers: optipng pngquant advpng pngout zopflipng pngcrush gifsicle jpegoptim jpeg-recompress jpegtran svgo (only minification, no downloading) You can also specifiy extra options for the minifiers: $this->taskImageMinify('assets/images/*.jpg') ->to('dist/images/') ->minifier('jpegtran', ['-progressive' => null, '-copy' => 'none']) ->run(); This will execute as: jpegtran -copy none -progressive -optimize -outfile \"dist/images/test.jpg\" \"/var/www/test/assets/images/test.jpg\" to($target) Sets the target directory where the files will be copied to. minifier($minifier, array $options = Array ( ) ) Sets the minifier. setOutput($output) Sets the Console Output.","title":"ImageMinify"},{"location":"tasks/Assets/#less","text":"Compiles less files. <?php $this->taskLess([ 'less/default.less' => 'css/default.css' ]) ->run(); ?> Use one of both less compilers in your project: \"leafo/lessphp\": \"~0.5\", \"oyejorge/less.php\": \"~1.5\" Specify directory (string or array) for less imports lookup: <?php $this->taskLess([ 'less/default.less' => 'css/default.css' ]) ->importDir('less') ->compiler('lessphp') ->run(); ?> You can implement additional compilers by extending this task and adding a method named after them and overloading the lessCompilers() method to inject the name there. importDir($dirs) Sets import directories addImportPath($dir) Adds import directory setImportPaths($dirs) Sets import directories setFormatter($formatterName) * param string $formatterName compiler($compiler, array $options = Array ( ) ) Sets the compiler. setOutput($output) Sets the Console Output.","title":"Less"},{"location":"tasks/Assets/#minify","text":"Minifies an asset file (CSS or JS). <?php $this->taskMinify('web/assets/theme.css') ->run() ?> Please install additional packages to use this task: composer require patchwork/jsqueeze:^2.0 composer require natxet/cssmin:^3.0 to($dst) Sets destination. Tries to guess type from it. type($type) Sets type with validation. singleLine($singleLine) Single line option for the JS minimisation. keepImportantComments($keepImportantComments) keepImportantComments option for the JS minimisation. specialVarRx($specialVarRx) Set specialVarRx option for the JS minimisation. __toString() @return string setOutput($output) Sets the Console Output.","title":"Minify"},{"location":"tasks/Assets/#scss","text":"Compiles scss files. <?php $this->taskScss([ 'scss/default.scss' => 'css/default.css' ]) ->importDir('assets/styles') ->run(); ?> Use the following scss compiler in your project: \"scssphp/scssphp \": \"~1.0.0\", You can implement additional compilers by extending this task and adding a method named after them and overloading the scssCompilers() method to inject the name there. setFormatter($formatterName) Sets the formatter for scssphp importDir($dirs) Sets import directories addImportPath($dir) Adds import directory setImportPaths($dirs) Sets import directories compiler($compiler, array $options = Array ( ) ) Sets the compiler. setOutput($output) Sets the Console Output.","title":"Scss"},{"location":"tasks/Base/","text":"Base Tasks Exec Executes shell script. Closes it when running in background mode. <?php $this->taskExec('compass')->arg('watch')->run(); // or use shortcut $this->_exec('compass watch'); $this->taskExec('compass watch')->background()->run(); if ($this->taskExec('phpunit .')->run()->wasSuccessful()) { $this->say('tests passed'); } ?> simulate($context) {@inheritdoc} setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. ExecStack Execute commands one by one in stack. Stack can be stopped on first fail if you call stopOnFail() . <?php $this->taskExecStack() ->stopOnFail() ->exec('mkdir site') ->exec('cd site') ->run(); ?> executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command ParallelExec Class ParallelExecTask <?php $this->taskParallelExec() ->process('php ~/demos/script.php hey') ->process('php ~/demos/script.php hoy') ->process('php ~/demos/script.php gou') ->run(); ?> process($command) * param string|\\Robo\\Contract\\CommandInterface $command waitInterval($waitInterval) Parallel processing will wait $waitInterval seconds after launching each process and before setOutput($output) Sets the Console Output. SymfonyCommand Executes Symfony Command <?php // Symfony Command $this->taskSymfonyCommand(new \\Codeception\\Command\\Run('run')) ->arg('suite','acceptance') ->opt('debug') ->run(); // Artisan Command $this->taskSymfonyCommand(new ModelGeneratorCommand()) ->arg('name', 'User') ->run(); ?> arg($arg, $value) * param string $arg opt($option, $value = null) setOutput($output) Sets the Console Output. Watch Runs task when specified file or dir was changed. Uses Lurker library. Monitor third parameter takes Lurker filesystem events types to watch. By default its set to MODIFY event. <?php $this->taskWatch() ->monitor( 'composer.json', function() { $this->taskComposerUpdate()->run(); } )->monitor( 'src', function() { $this->taskExec('phpunit')->run(); }, \\Lurker\\Event\\FilesystemEvent::ALL )->monitor( 'migrations', function() { //do something }, [ \\Lurker\\Event\\FilesystemEvent::CREATE, \\Lurker\\Event\\FilesystemEvent::DELETE ] )->run(); ?> Pass through the changed file to the callable function $this ->taskWatch() ->monitor( 'filename', function ($event) { $resource = $event->getResource(); ... do something with (string)$resource ... }, FilesystemEvent::ALL ) ->run(); The $event parameter is a standard Symfony file resource object monitor($paths, $callable, $events = null) * param string|string[] $paths setOutput($output) Sets the Console Output.","title":"Base Tasks"},{"location":"tasks/Base/#base-tasks","text":"","title":"Base Tasks"},{"location":"tasks/Base/#exec","text":"Executes shell script. Closes it when running in background mode. <?php $this->taskExec('compass')->arg('watch')->run(); // or use shortcut $this->_exec('compass watch'); $this->taskExec('compass watch')->background()->run(); if ($this->taskExec('phpunit .')->run()->wasSuccessful()) { $this->say('tests passed'); } ?> simulate($context) {@inheritdoc} setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Exec"},{"location":"tasks/Base/#execstack","text":"Execute commands one by one in stack. Stack can be stopped on first fail if you call stopOnFail() . <?php $this->taskExecStack() ->stopOnFail() ->exec('mkdir site') ->exec('cd site') ->run(); ?> executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command","title":"ExecStack"},{"location":"tasks/Base/#parallelexec","text":"Class ParallelExecTask <?php $this->taskParallelExec() ->process('php ~/demos/script.php hey') ->process('php ~/demos/script.php hoy') ->process('php ~/demos/script.php gou') ->run(); ?> process($command) * param string|\\Robo\\Contract\\CommandInterface $command waitInterval($waitInterval) Parallel processing will wait $waitInterval seconds after launching each process and before setOutput($output) Sets the Console Output.","title":"ParallelExec"},{"location":"tasks/Base/#symfonycommand","text":"Executes Symfony Command <?php // Symfony Command $this->taskSymfonyCommand(new \\Codeception\\Command\\Run('run')) ->arg('suite','acceptance') ->opt('debug') ->run(); // Artisan Command $this->taskSymfonyCommand(new ModelGeneratorCommand()) ->arg('name', 'User') ->run(); ?> arg($arg, $value) * param string $arg opt($option, $value = null) setOutput($output) Sets the Console Output.","title":"SymfonyCommand"},{"location":"tasks/Base/#watch","text":"Runs task when specified file or dir was changed. Uses Lurker library. Monitor third parameter takes Lurker filesystem events types to watch. By default its set to MODIFY event. <?php $this->taskWatch() ->monitor( 'composer.json', function() { $this->taskComposerUpdate()->run(); } )->monitor( 'src', function() { $this->taskExec('phpunit')->run(); }, \\Lurker\\Event\\FilesystemEvent::ALL )->monitor( 'migrations', function() { //do something }, [ \\Lurker\\Event\\FilesystemEvent::CREATE, \\Lurker\\Event\\FilesystemEvent::DELETE ] )->run(); ?> Pass through the changed file to the callable function $this ->taskWatch() ->monitor( 'filename', function ($event) { $resource = $event->getResource(); ... do something with (string)$resource ... }, FilesystemEvent::ALL ) ->run(); The $event parameter is a standard Symfony file resource object monitor($paths, $callable, $events = null) * param string|string[] $paths setOutput($output) Sets the Console Output.","title":"Watch"},{"location":"tasks/Bower/","text":"Bower Tasks Install Bower Install <?php // simple execution $this->taskBowerInstall()->run(); // prefer dist with custom path $this->taskBowerInstall('path/to/my/bower') ->noDev() ->run(); ?> allowRoot() adds allow-root option to bower forceLatest() adds force-latest option to bower noDev() adds production option to bower offline() adds offline option to bower setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Update Bower Update <?php // simple execution $this->taskBowerUpdate->run(); // prefer dist with custom path $this->taskBowerUpdate('path/to/my/bower') ->noDev() ->run(); ?> allowRoot() adds allow-root option to bower forceLatest() adds force-latest option to bower noDev() adds production option to bower offline() adds offline option to bower setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Bower Tasks"},{"location":"tasks/Bower/#bower-tasks","text":"","title":"Bower Tasks"},{"location":"tasks/Bower/#install","text":"Bower Install <?php // simple execution $this->taskBowerInstall()->run(); // prefer dist with custom path $this->taskBowerInstall('path/to/my/bower') ->noDev() ->run(); ?> allowRoot() adds allow-root option to bower forceLatest() adds force-latest option to bower noDev() adds production option to bower offline() adds offline option to bower setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Install"},{"location":"tasks/Bower/#update","text":"Bower Update <?php // simple execution $this->taskBowerUpdate->run(); // prefer dist with custom path $this->taskBowerUpdate('path/to/my/bower') ->noDev() ->run(); ?> allowRoot() adds allow-root option to bower forceLatest() adds force-latest option to bower noDev() adds production option to bower offline() adds offline option to bower setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Update"},{"location":"tasks/Composer/","text":"Composer Tasks CheckPlatformReqs Composer Check Platform Requirements <?php // simple execution $this->taskComposerValidate()->run(); ?> preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Config Composer Config <?php // simple execution $this->taskComposerConfig()->set('bin-dir', 'bin/')->run(); ?> set($key, $value) Set a configuration value. useGlobal($useGlobal = null) Operate on the global repository repository($id, $uri, $repoType = null) * param string $id removeRepository($id) * param string $id disableRepository($id) * param string $id enableRepository($id) * param string $id preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. CreateProject Composer CreateProject <?php // simple execution $this->taskComposerCreateProject()->source('foo/bar')->target('myBar')->run(); ?> source($source) * param string $source target($target) * param string $target version($version) * param string $version keepVcs($keep = null) * param bool $keep noInstall($noInstall = null) * param bool $noInstall repository($repository) * param string $repository stability($stability) * param string $stability buildCommand() {@inheritdoc} preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. DumpAutoload Composer Dump Autoload <?php // simple execution $this->taskComposerDumpAutoload()->run(); // dump auto loader with custom path $this->taskComposerDumpAutoload('path/to/my/composer.phar') ->preferDist() ->run(); // optimize autoloader dump with custom path $this->taskComposerDumpAutoload('path/to/my/composer.phar') ->optimize() ->run(); // optimize autoloader dump with custom path and no dev $this->taskComposerDumpAutoload('path/to/my/composer.phar') ->optimize() ->noDev() ->run(); ?> optimize($optimize = null) * param bool $optimize preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Init Composer Init <?php // simple execution $this->taskComposerInit()->run(); ?> projectName($projectName) * param string $projectName description($description) * param string $description author($author) * param string $author projectType($type) * param string $type homepage($homepage) * param string $homepage dependency($project, $version = null) 'require' is a keyword, so it cannot be a method name. stability($stability) * param string $stability license($license) * param string $license repository($repository) * param string $repository preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Install Composer Install <?php // simple execution $this->taskComposerInstall()->run(); // prefer dist with custom path $this->taskComposerInstall('path/to/my/composer.phar') ->preferDist() ->run(); // optimize autoloader with custom path $this->taskComposerInstall('path/to/my/composer.phar') ->optimizeAutoloader() ->run(); ?> noSuggest($noSuggest = null) adds no-suggest option to composer preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Remove Composer Remove <?php // simple execution $this->taskComposerRemove()->run(); ?> dev($dev = null) * param bool $dev noProgress($noProgress = null) * param bool $noProgress noUpdate($noUpdate = null) * param bool $noUpdate updateNoDev($updateNoDev = null) * param bool $updateNoDev noUpdateWithDependencies($updateWithDependencies = null) * param bool $updateWithDependencies preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. RequireDependency Composer Require <?php // simple execution $this->taskComposerRequire()->dependency('foo/bar', '^.2.4.8')->run(); ?> dependency($project, $version = null) 'require' is a keyword, so it cannot be a method name. noSuggest($noSuggest = null) adds no-suggest option to composer preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Update Composer Update <?php // simple execution $this->taskComposerUpdate()->run(); // prefer dist with custom path $this->taskComposerUpdate('path/to/my/composer.phar') ->preferDist() ->run(); // optimize autoloader with custom path $this->taskComposerUpdate('path/to/my/composer.phar') ->optimizeAutoloader() ->run(); ?> noSuggest($noSuggest = null) adds no-suggest option to composer preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Validate Composer Validate <?php // simple execution $this->taskComposerValidate()->run(); ?> noCheckAll($noCheckAll = null) * param bool $noCheckAll noCheckLock($noCheckLock = null) * param bool $noCheckLock noCheckPublish($noCheckPublish = null) * param bool $noCheckPublish withDependencies($withDependencies = null) * param bool $withDependencies strict($strict = null) * param bool $strict preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Composer Tasks"},{"location":"tasks/Composer/#composer-tasks","text":"","title":"Composer Tasks"},{"location":"tasks/Composer/#checkplatformreqs","text":"Composer Check Platform Requirements <?php // simple execution $this->taskComposerValidate()->run(); ?> preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"CheckPlatformReqs"},{"location":"tasks/Composer/#config","text":"Composer Config <?php // simple execution $this->taskComposerConfig()->set('bin-dir', 'bin/')->run(); ?> set($key, $value) Set a configuration value. useGlobal($useGlobal = null) Operate on the global repository repository($id, $uri, $repoType = null) * param string $id removeRepository($id) * param string $id disableRepository($id) * param string $id enableRepository($id) * param string $id preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Config"},{"location":"tasks/Composer/#createproject","text":"Composer CreateProject <?php // simple execution $this->taskComposerCreateProject()->source('foo/bar')->target('myBar')->run(); ?> source($source) * param string $source target($target) * param string $target version($version) * param string $version keepVcs($keep = null) * param bool $keep noInstall($noInstall = null) * param bool $noInstall repository($repository) * param string $repository stability($stability) * param string $stability buildCommand() {@inheritdoc} preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"CreateProject"},{"location":"tasks/Composer/#dumpautoload","text":"Composer Dump Autoload <?php // simple execution $this->taskComposerDumpAutoload()->run(); // dump auto loader with custom path $this->taskComposerDumpAutoload('path/to/my/composer.phar') ->preferDist() ->run(); // optimize autoloader dump with custom path $this->taskComposerDumpAutoload('path/to/my/composer.phar') ->optimize() ->run(); // optimize autoloader dump with custom path and no dev $this->taskComposerDumpAutoload('path/to/my/composer.phar') ->optimize() ->noDev() ->run(); ?> optimize($optimize = null) * param bool $optimize preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"DumpAutoload"},{"location":"tasks/Composer/#init","text":"Composer Init <?php // simple execution $this->taskComposerInit()->run(); ?> projectName($projectName) * param string $projectName description($description) * param string $description author($author) * param string $author projectType($type) * param string $type homepage($homepage) * param string $homepage dependency($project, $version = null) 'require' is a keyword, so it cannot be a method name. stability($stability) * param string $stability license($license) * param string $license repository($repository) * param string $repository preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Init"},{"location":"tasks/Composer/#install","text":"Composer Install <?php // simple execution $this->taskComposerInstall()->run(); // prefer dist with custom path $this->taskComposerInstall('path/to/my/composer.phar') ->preferDist() ->run(); // optimize autoloader with custom path $this->taskComposerInstall('path/to/my/composer.phar') ->optimizeAutoloader() ->run(); ?> noSuggest($noSuggest = null) adds no-suggest option to composer preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Install"},{"location":"tasks/Composer/#remove","text":"Composer Remove <?php // simple execution $this->taskComposerRemove()->run(); ?> dev($dev = null) * param bool $dev noProgress($noProgress = null) * param bool $noProgress noUpdate($noUpdate = null) * param bool $noUpdate updateNoDev($updateNoDev = null) * param bool $updateNoDev noUpdateWithDependencies($updateWithDependencies = null) * param bool $updateWithDependencies preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Remove"},{"location":"tasks/Composer/#requiredependency","text":"Composer Require <?php // simple execution $this->taskComposerRequire()->dependency('foo/bar', '^.2.4.8')->run(); ?> dependency($project, $version = null) 'require' is a keyword, so it cannot be a method name. noSuggest($noSuggest = null) adds no-suggest option to composer preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"RequireDependency"},{"location":"tasks/Composer/#update","text":"Composer Update <?php // simple execution $this->taskComposerUpdate()->run(); // prefer dist with custom path $this->taskComposerUpdate('path/to/my/composer.phar') ->preferDist() ->run(); // optimize autoloader with custom path $this->taskComposerUpdate('path/to/my/composer.phar') ->optimizeAutoloader() ->run(); ?> noSuggest($noSuggest = null) adds no-suggest option to composer preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Update"},{"location":"tasks/Composer/#validate","text":"Composer Validate <?php // simple execution $this->taskComposerValidate()->run(); ?> noCheckAll($noCheckAll = null) * param bool $noCheckAll noCheckLock($noCheckLock = null) * param bool $noCheckLock noCheckPublish($noCheckPublish = null) * param bool $noCheckPublish withDependencies($withDependencies = null) * param bool $withDependencies strict($strict = null) * param bool $strict preferDist($preferDist = null) adds prefer-dist option to composer preferSource() adds prefer-source option to composer dev($dev = null) adds dev option to composer noDev() adds no-dev option to composer ansi($ansi = null) adds ansi option to composer noAnsi() adds no-ansi option to composer interaction($interaction = null) * param bool $interaction noInteraction() adds no-interaction option to composer optimizeAutoloader($optimize = null) adds optimize-autoloader option to composer ignorePlatformRequirements($ignore = null) adds ignore-platform-reqs option to composer disablePlugins($disable = null) disable plugins noScripts($disable = null) skip scripts workingDir($dir) adds --working-dir $dir option to composer buildCommand() Copy class fields into command options as directed. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Validate"},{"location":"tasks/Development/","text":"Development Tasks Changelog Helps to manage changelog file. Creates or updates changelog.md file with recent changes in current version. <?php $version = \"0.1.0\"; $this->taskChangelog() ->version($version) ->change(\"released to github\") ->run(); ?> Changes can be asked from Console <?php $this->taskChangelog() ->version($version) ->askForChanges() ->run(); ?> filename($filename) * param string $filename setBody($body) Sets the changelog body text. setHeader($header) * param string $header log($item) * param string $item anchor($anchor) * param string $anchor version($version) * param string $version changes(array $data) * param array $data change($change) * param string $change getChanges() @return array processLogRow($i) * param string $i setOutput($output) Sets the Console Output. GenerateMarkdownDoc Simple documentation generator from source files. Takes classes, properties and methods with their docblocks and writes down a markdown file. <?php $this->taskGenDoc('models.md') ->docClass('Model\\User') // take class Model\\User ->docClass('Model\\Post') // take class Model\\Post ->filterMethods(function(\\ReflectionMethod $r) { return $r->isPublic() or $r->isProtected(); // process public and protected methods })->processClass(function(\\ReflectionClass $r, $text) { return \"Class \".$r->getName().\"\\n\\n$text\\n\\n###Methods\\n\"; })->run(); By default this task generates a documentation for each public method of a class, interface or trait. It combines method signature with a docblock. Both can be post-processed. <?php $this->taskGenDoc('models.md') ->docClass('Model\\User') ->processClassSignature(false) // false can be passed to not include class signature ->processClassDocBlock(function(\\ReflectionClass $r, $text) { return \"[This is part of application model]\\n\" . $text; })->processMethodSignature(function(\\ReflectionMethod $r, $text) { return \"#### {$r->name}()\"; })->processMethodDocBlock(function(\\ReflectionMethod $r, $text) { return strpos($r->name, 'save')===0 ? \"[Saves to the database]\\n\" . $text : $text; })->run(); docClass($item) Put a class you want to be documented. filterMethods($filterMethods) Using a callback function filter out methods that won't be documented. filterClasses($filterClasses) Using a callback function filter out classes that won't be documented. filterProperties($filterProperties) Using a callback function filter out properties that won't be documented. processClass($processClass) Post-process class documentation. processClassSignature($processClassSignature) Post-process class signature. Provide false to skip. processClassDocBlock($processClassDocBlock) Post-process class docblock contents. Provide false to skip. processMethod($processMethod) Post-process method documentation. Provide false to skip. processMethodSignature($processMethodSignature) Post-process method signature. Provide false to skip. processMethodDocBlock($processMethodDocBlock) Post-process method docblock contents. Provide false to skip. processProperty($processProperty) Post-process property documentation. Provide false to skip. processPropertySignature($processPropertySignature) Post-process property signature. Provide false to skip. processPropertyDocBlock($processPropertyDocBlock) Post-process property docblock contents. Provide false to skip. reorder($reorder) Use a function to reorder classes. reorderMethods($reorderMethods) Use a function to reorder methods in class. reorderProperties($reorderProperties) * param callable $reorderProperties filename($filename) * param string $filename prepend($prepend) Inserts text at the beginning of markdown file. append($append) Inserts text at the end of markdown file. text($text) * param string $text textForClass($item) * param string $item setOutput($output) Sets the Console Output. Generate Generate a Robo Task that is a wrapper around an existing class. <?php $this->taskGenerateTask('Symfony\\Component\\Filesystem\\Filesystem', 'FilesystemStack') ->run(); setOutput($output) Sets the Console Output. GitHubRelease Publishes new GitHub release. <?php $this->taskGitHubRelease('0.1.0') ->uri('consolidation-org/Robo') ->description('Add stuff people need.') ->change('Fix #123') ->change('Add frobulation method to all widgets') ->run(); ?> tag($tag) * param string $tag draft($draft) * param bool $draft name($name) * param string $name description($description) * param string $description prerelease($prerelease) * param bool $prerelease comittish($comittish) * param string $comittish appendDescription($description) * param string $description changes(array $changes) change($change) * param string $change repo($repo) * param string $repo owner($owner) * param string $owner uri($uri) * param string $uri user($user) * param string $user password($password) * param string $password accessToken($token) * param string $token setOutput($output) Sets the Console Output. OpenBrowser Opens the default's user browser code inspired from openBrowser() function in https://github.com/composer/composer/blob/master/src/Composer/Command/HomeCommand.php <?php // open one browser window $this->taskOpenBrowser('http://localhost') ->run(); // open two browser windows $this->taskOpenBrowser([ 'http://localhost/mysite', 'http://localhost/mysite2' ]) ->run(); setOutput($output) Sets the Console Output. PackPhar Creates Phar. <?php $pharTask = $this->taskPackPhar('package/codecept.phar') ->compress() ->stub('package/stub.php'); $finder = Finder::create() ->name('*.php') ->in('src'); foreach ($finder as $file) { $pharTask->addFile('src/'.$file->getRelativePathname(), $file->getRealPath()); } $finder = Finder::create()->files() ->name('*.php') ->in('vendor'); foreach ($finder as $file) { $pharTask->addStripped('vendor/'.$file->getRelativePathname(), $file->getRealPath()); } $pharTask->run(); // verify Phar is packed correctly $code = $this->_exec('php package/codecept.phar'); ?> compress($compress = null) * param bool $compress stub($stub) * param string $stub addStripped($path, $file) * param string $path addFile($path, $file) * param string $path addFiles($files) * param \\Symfony\\Component\\Finder\\SplFileInfo[] $files executable($file) * param string $file setOutput($output) Sets the Console Output. PhpServer Runs PHP server and stops it when task finishes. <?php // run server in /public directory $this->taskServer(8000) ->dir('public') ->run(); // run with IP 0.0.0.0 $this->taskServer(8000) ->host('0.0.0.0') ->run(); // execute server in background $this->taskServer(8000) ->background() ->run(); ?> host($host) * param string $host dir($path) * param string $path simulate($context) {@inheritdoc} setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. SemVer Helps to maintain .semver file. <?php $this->taskSemVer('.semver') ->increment() ->run(); ?> __toString() @return string version($version) * param string $version setFormat($format) * param string $format setMetadataSeparator($separator) * param string $separator setPrereleaseSeparator($separator) * param string $separator increment($what = null) * param string $what prerelease($tag = null) * param string $tag metadata($data) * param array|string $data","title":"Development Tasks"},{"location":"tasks/Development/#development-tasks","text":"","title":"Development Tasks"},{"location":"tasks/Development/#changelog","text":"Helps to manage changelog file. Creates or updates changelog.md file with recent changes in current version. <?php $version = \"0.1.0\"; $this->taskChangelog() ->version($version) ->change(\"released to github\") ->run(); ?> Changes can be asked from Console <?php $this->taskChangelog() ->version($version) ->askForChanges() ->run(); ?> filename($filename) * param string $filename setBody($body) Sets the changelog body text. setHeader($header) * param string $header log($item) * param string $item anchor($anchor) * param string $anchor version($version) * param string $version changes(array $data) * param array $data change($change) * param string $change getChanges() @return array processLogRow($i) * param string $i setOutput($output) Sets the Console Output.","title":"Changelog"},{"location":"tasks/Development/#generatemarkdowndoc","text":"Simple documentation generator from source files. Takes classes, properties and methods with their docblocks and writes down a markdown file. <?php $this->taskGenDoc('models.md') ->docClass('Model\\User') // take class Model\\User ->docClass('Model\\Post') // take class Model\\Post ->filterMethods(function(\\ReflectionMethod $r) { return $r->isPublic() or $r->isProtected(); // process public and protected methods })->processClass(function(\\ReflectionClass $r, $text) { return \"Class \".$r->getName().\"\\n\\n$text\\n\\n###Methods\\n\"; })->run(); By default this task generates a documentation for each public method of a class, interface or trait. It combines method signature with a docblock. Both can be post-processed. <?php $this->taskGenDoc('models.md') ->docClass('Model\\User') ->processClassSignature(false) // false can be passed to not include class signature ->processClassDocBlock(function(\\ReflectionClass $r, $text) { return \"[This is part of application model]\\n\" . $text; })->processMethodSignature(function(\\ReflectionMethod $r, $text) { return \"#### {$r->name}()\"; })->processMethodDocBlock(function(\\ReflectionMethod $r, $text) { return strpos($r->name, 'save')===0 ? \"[Saves to the database]\\n\" . $text : $text; })->run(); docClass($item) Put a class you want to be documented. filterMethods($filterMethods) Using a callback function filter out methods that won't be documented. filterClasses($filterClasses) Using a callback function filter out classes that won't be documented. filterProperties($filterProperties) Using a callback function filter out properties that won't be documented. processClass($processClass) Post-process class documentation. processClassSignature($processClassSignature) Post-process class signature. Provide false to skip. processClassDocBlock($processClassDocBlock) Post-process class docblock contents. Provide false to skip. processMethod($processMethod) Post-process method documentation. Provide false to skip. processMethodSignature($processMethodSignature) Post-process method signature. Provide false to skip. processMethodDocBlock($processMethodDocBlock) Post-process method docblock contents. Provide false to skip. processProperty($processProperty) Post-process property documentation. Provide false to skip. processPropertySignature($processPropertySignature) Post-process property signature. Provide false to skip. processPropertyDocBlock($processPropertyDocBlock) Post-process property docblock contents. Provide false to skip. reorder($reorder) Use a function to reorder classes. reorderMethods($reorderMethods) Use a function to reorder methods in class. reorderProperties($reorderProperties) * param callable $reorderProperties filename($filename) * param string $filename prepend($prepend) Inserts text at the beginning of markdown file. append($append) Inserts text at the end of markdown file. text($text) * param string $text textForClass($item) * param string $item setOutput($output) Sets the Console Output.","title":"GenerateMarkdownDoc"},{"location":"tasks/Development/#generate","text":"Generate a Robo Task that is a wrapper around an existing class. <?php $this->taskGenerateTask('Symfony\\Component\\Filesystem\\Filesystem', 'FilesystemStack') ->run(); setOutput($output) Sets the Console Output.","title":"Generate"},{"location":"tasks/Development/#githubrelease","text":"Publishes new GitHub release. <?php $this->taskGitHubRelease('0.1.0') ->uri('consolidation-org/Robo') ->description('Add stuff people need.') ->change('Fix #123') ->change('Add frobulation method to all widgets') ->run(); ?> tag($tag) * param string $tag draft($draft) * param bool $draft name($name) * param string $name description($description) * param string $description prerelease($prerelease) * param bool $prerelease comittish($comittish) * param string $comittish appendDescription($description) * param string $description changes(array $changes) change($change) * param string $change repo($repo) * param string $repo owner($owner) * param string $owner uri($uri) * param string $uri user($user) * param string $user password($password) * param string $password accessToken($token) * param string $token setOutput($output) Sets the Console Output.","title":"GitHubRelease"},{"location":"tasks/Development/#openbrowser","text":"Opens the default's user browser code inspired from openBrowser() function in https://github.com/composer/composer/blob/master/src/Composer/Command/HomeCommand.php <?php // open one browser window $this->taskOpenBrowser('http://localhost') ->run(); // open two browser windows $this->taskOpenBrowser([ 'http://localhost/mysite', 'http://localhost/mysite2' ]) ->run(); setOutput($output) Sets the Console Output.","title":"OpenBrowser"},{"location":"tasks/Development/#packphar","text":"Creates Phar. <?php $pharTask = $this->taskPackPhar('package/codecept.phar') ->compress() ->stub('package/stub.php'); $finder = Finder::create() ->name('*.php') ->in('src'); foreach ($finder as $file) { $pharTask->addFile('src/'.$file->getRelativePathname(), $file->getRealPath()); } $finder = Finder::create()->files() ->name('*.php') ->in('vendor'); foreach ($finder as $file) { $pharTask->addStripped('vendor/'.$file->getRelativePathname(), $file->getRealPath()); } $pharTask->run(); // verify Phar is packed correctly $code = $this->_exec('php package/codecept.phar'); ?> compress($compress = null) * param bool $compress stub($stub) * param string $stub addStripped($path, $file) * param string $path addFile($path, $file) * param string $path addFiles($files) * param \\Symfony\\Component\\Finder\\SplFileInfo[] $files executable($file) * param string $file setOutput($output) Sets the Console Output.","title":"PackPhar"},{"location":"tasks/Development/#phpserver","text":"Runs PHP server and stops it when task finishes. <?php // run server in /public directory $this->taskServer(8000) ->dir('public') ->run(); // run with IP 0.0.0.0 $this->taskServer(8000) ->host('0.0.0.0') ->run(); // execute server in background $this->taskServer(8000) ->background() ->run(); ?> host($host) * param string $host dir($path) * param string $path simulate($context) {@inheritdoc} setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"PhpServer"},{"location":"tasks/Development/#semver","text":"Helps to maintain .semver file. <?php $this->taskSemVer('.semver') ->increment() ->run(); ?> __toString() @return string version($version) * param string $version setFormat($format) * param string $format setMetadataSeparator($separator) * param string $separator setPrereleaseSeparator($separator) * param string $separator increment($what = null) * param string $what prerelease($tag = null) * param string $tag metadata($data) * param array|string $data","title":"SemVer"},{"location":"tasks/Docker/","text":"Docker Tasks Build Builds Docker image <?php $this->taskDockerBuild()->run(); $this->taskDockerBuild('path/to/dir') ->tag('database') ->run(); ?> Class Build @package Robo\\Task\\Docker tag($tag) * param string $tag enableBuildKit() * return $this setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Commit Commits docker container to an image $this->taskDockerCommit($containerId) ->name('my/database') ->run(); // alternatively you can take the result from DockerRun task: $result = $this->taskDockerRun('db') ->exec('./prepare_database.sh') ->run(); $task->dockerCommit($result) ->name('my/database') ->run(); name($name) * param string $name setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Exec Executes command inside running Docker container <?php $test = $this->taskDockerRun('test_env') ->detached() ->run(); $this->taskDockerExec($test) ->interactive() ->exec('./runtests') ->run(); // alternatively use commands from other tasks $this->taskDockerExec($test) ->interactive() ->exec($this->taskCodecept()->suite('acceptance')) ->run(); ?> detached() * return $this exec($command) * param string|\\Robo\\Contract\\CommandInterface $command setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Pull Pulls an image from DockerHub <?php $this->taskDockerPull('wordpress') ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Remove Remove docker container <?php $this->taskDockerRemove($container) ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Run Performs docker run on a container. <?php $this->taskDockerRun('mysql')->run(); $result = $this->taskDockerRun('my_db_image') ->env('DB', 'database_name') ->volume('/path/to/data', '/data') ->detached() ->publish(3306) ->name('my_mysql') ->run(); // retrieve container's cid: $this->say(\"Running container \".$result->getCid()); // execute script inside container $result = $this->taskDockerRun('db') ->exec('prepare_test_data.sh') ->run(); $this->taskDockerCommit($result) ->name('test_db') ->run(); // link containers $mysql = $this->taskDockerRun('mysql') ->name('wp_db') // important to set name for linked container ->env('MYSQL_ROOT_PASSWORD', '123456') ->run(); $this->taskDockerRun('wordpress') ->link($mysql) ->publish(80, 8080) ->detached() ->run(); ?> detached() * return $this exec($run) * param string|\\Robo\\Contract\\CommandInterface $run volume($from, $to = null) * param string $from publish($port = null, $portTo = null) * param null|int $port containerWorkdir($dir) * param string $dir user($user) * param string $user privileged() * return $this name($name) * param string $name link($name, $alias) * param string|\\Robo\\Task\\Docker\\Result $name tmpDir($dir) * param string $dir getTmpDir() @return string getUniqId() @return string setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Start Starts Docker container <?php $this->taskDockerStart($cidOrResult) ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Stop Stops Docker container <?php $this->taskDockerStop($cidOrResult) ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Docker Tasks"},{"location":"tasks/Docker/#docker-tasks","text":"","title":"Docker Tasks"},{"location":"tasks/Docker/#build","text":"Builds Docker image <?php $this->taskDockerBuild()->run(); $this->taskDockerBuild('path/to/dir') ->tag('database') ->run(); ?> Class Build @package Robo\\Task\\Docker tag($tag) * param string $tag enableBuildKit() * return $this setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Build"},{"location":"tasks/Docker/#commit","text":"Commits docker container to an image $this->taskDockerCommit($containerId) ->name('my/database') ->run(); // alternatively you can take the result from DockerRun task: $result = $this->taskDockerRun('db') ->exec('./prepare_database.sh') ->run(); $task->dockerCommit($result) ->name('my/database') ->run(); name($name) * param string $name setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Commit"},{"location":"tasks/Docker/#exec","text":"Executes command inside running Docker container <?php $test = $this->taskDockerRun('test_env') ->detached() ->run(); $this->taskDockerExec($test) ->interactive() ->exec('./runtests') ->run(); // alternatively use commands from other tasks $this->taskDockerExec($test) ->interactive() ->exec($this->taskCodecept()->suite('acceptance')) ->run(); ?> detached() * return $this exec($command) * param string|\\Robo\\Contract\\CommandInterface $command setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Exec"},{"location":"tasks/Docker/#pull","text":"Pulls an image from DockerHub <?php $this->taskDockerPull('wordpress') ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Pull"},{"location":"tasks/Docker/#remove","text":"Remove docker container <?php $this->taskDockerRemove($container) ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Remove"},{"location":"tasks/Docker/#run","text":"Performs docker run on a container. <?php $this->taskDockerRun('mysql')->run(); $result = $this->taskDockerRun('my_db_image') ->env('DB', 'database_name') ->volume('/path/to/data', '/data') ->detached() ->publish(3306) ->name('my_mysql') ->run(); // retrieve container's cid: $this->say(\"Running container \".$result->getCid()); // execute script inside container $result = $this->taskDockerRun('db') ->exec('prepare_test_data.sh') ->run(); $this->taskDockerCommit($result) ->name('test_db') ->run(); // link containers $mysql = $this->taskDockerRun('mysql') ->name('wp_db') // important to set name for linked container ->env('MYSQL_ROOT_PASSWORD', '123456') ->run(); $this->taskDockerRun('wordpress') ->link($mysql) ->publish(80, 8080) ->detached() ->run(); ?> detached() * return $this exec($run) * param string|\\Robo\\Contract\\CommandInterface $run volume($from, $to = null) * param string $from publish($port = null, $portTo = null) * param null|int $port containerWorkdir($dir) * param string $dir user($user) * param string $user privileged() * return $this name($name) * param string $name link($name, $alias) * param string|\\Robo\\Task\\Docker\\Result $name tmpDir($dir) * param string $dir getTmpDir() @return string getUniqId() @return string setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Run"},{"location":"tasks/Docker/#start","text":"Starts Docker container <?php $this->taskDockerStart($cidOrResult) ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Start"},{"location":"tasks/Docker/#stop","text":"Stops Docker container <?php $this->taskDockerStop($cidOrResult) ->run(); ?> setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Stop"},{"location":"tasks/File/","text":"File Tasks Concat Merges files into one. Used for preparing assets. <?php $this->taskConcat([ 'web/assets/screen.css', 'web/assets/print.css', 'web/assets/theme.css' ]) ->to('web/assets/style.css') ->run() ?> to($dst) set the destination file setOutput($output) Sets the Console Output. Replace Performs search and replace inside a files. <?php $this->taskReplaceInFile('VERSION') ->from('0.2.0') ->to('0.3.0') ->run(); $this->taskReplaceInFile('README.md') ->from(date('Y')-1) ->to(date('Y')) ->run(); $this->taskReplaceInFile('config.yml') ->regex('~^service:~') ->to('services:') ->run(); $this->taskReplaceInFile('box/robo.txt') ->from(array('##dbname##', '##dbhost##')) ->to(array('robo', 'localhost')) ->run(); ?> filename($filename) * param string $filename from($from) String(s) to be replaced. to($to) Value(s) to be set as a replacement. regex($regex) Regex to match string to be replaced. limit($limit) If used with $this->regexp() how many counts will be replaced setOutput($output) Sets the Console Output. TmpFile Create a temporary file that is automatically cleaned up once the task collection is is part of completes. When created, it is given a random filename. This temporary file may be manipulated exacatly like taskWrite(). It is deleted as soon as the collection it is a part of completes or rolls back. <?php $collection = $this->collectionBuilder(); $tmpFilePath = $collection->taskTmpFile() ->line('-----') ->line(date('Y-m-d').' '.$title) ->line('----') ->getPath(); $collection->run(); ?> complete() Delete this file when our collection completes. filename($filename) * param string $filename append($append = null) * param bool $append line($line) add a line. lines(array $lines) add more lines. text($text) add a text. textFromFile($filename) add a text from a file. place($name, $val) substitute a placeholder with value, placeholder must be enclosed by {} . replace($string, $replacement) replace any string with value. regexReplace($pattern, $replacement) replace any string with value using regular expression. appendIfMatches($pattern, $text) Append the provided text to the end of the buffer if the provided appendUnlessMatches($pattern, $text) Append the provided text to the end of the buffer unless the provided originalContents() @return string wouldChange() @return bool getPath() @return string setOutput($output) Sets the Console Output. Write Writes to file. <?php $this->taskWriteToFile('blogpost.md') ->line('-----') ->line(date('Y-m-d').' '.$title) ->line('----') ->run(); ?> filename($filename) * param string $filename append($append = null) * param bool $append line($line) add a line. lines(array $lines) add more lines. text($text) add a text. textFromFile($filename) add a text from a file. place($name, $val) substitute a placeholder with value, placeholder must be enclosed by {} . replace($string, $replacement) replace any string with value. regexReplace($pattern, $replacement) replace any string with value using regular expression. appendIfMatches($pattern, $text) Append the provided text to the end of the buffer if the provided appendUnlessMatches($pattern, $text) Append the provided text to the end of the buffer unless the provided originalContents() @return string wouldChange() @return bool getPath() @return string setOutput($output) Sets the Console Output.","title":"File Tasks"},{"location":"tasks/File/#file-tasks","text":"","title":"File Tasks"},{"location":"tasks/File/#concat","text":"Merges files into one. Used for preparing assets. <?php $this->taskConcat([ 'web/assets/screen.css', 'web/assets/print.css', 'web/assets/theme.css' ]) ->to('web/assets/style.css') ->run() ?> to($dst) set the destination file setOutput($output) Sets the Console Output.","title":"Concat"},{"location":"tasks/File/#replace","text":"Performs search and replace inside a files. <?php $this->taskReplaceInFile('VERSION') ->from('0.2.0') ->to('0.3.0') ->run(); $this->taskReplaceInFile('README.md') ->from(date('Y')-1) ->to(date('Y')) ->run(); $this->taskReplaceInFile('config.yml') ->regex('~^service:~') ->to('services:') ->run(); $this->taskReplaceInFile('box/robo.txt') ->from(array('##dbname##', '##dbhost##')) ->to(array('robo', 'localhost')) ->run(); ?> filename($filename) * param string $filename from($from) String(s) to be replaced. to($to) Value(s) to be set as a replacement. regex($regex) Regex to match string to be replaced. limit($limit) If used with $this->regexp() how many counts will be replaced setOutput($output) Sets the Console Output.","title":"Replace"},{"location":"tasks/File/#tmpfile","text":"Create a temporary file that is automatically cleaned up once the task collection is is part of completes. When created, it is given a random filename. This temporary file may be manipulated exacatly like taskWrite(). It is deleted as soon as the collection it is a part of completes or rolls back. <?php $collection = $this->collectionBuilder(); $tmpFilePath = $collection->taskTmpFile() ->line('-----') ->line(date('Y-m-d').' '.$title) ->line('----') ->getPath(); $collection->run(); ?> complete() Delete this file when our collection completes. filename($filename) * param string $filename append($append = null) * param bool $append line($line) add a line. lines(array $lines) add more lines. text($text) add a text. textFromFile($filename) add a text from a file. place($name, $val) substitute a placeholder with value, placeholder must be enclosed by {} . replace($string, $replacement) replace any string with value. regexReplace($pattern, $replacement) replace any string with value using regular expression. appendIfMatches($pattern, $text) Append the provided text to the end of the buffer if the provided appendUnlessMatches($pattern, $text) Append the provided text to the end of the buffer unless the provided originalContents() @return string wouldChange() @return bool getPath() @return string setOutput($output) Sets the Console Output.","title":"TmpFile"},{"location":"tasks/File/#write","text":"Writes to file. <?php $this->taskWriteToFile('blogpost.md') ->line('-----') ->line(date('Y-m-d').' '.$title) ->line('----') ->run(); ?> filename($filename) * param string $filename append($append = null) * param bool $append line($line) add a line. lines(array $lines) add more lines. text($text) add a text. textFromFile($filename) add a text from a file. place($name, $val) substitute a placeholder with value, placeholder must be enclosed by {} . replace($string, $replacement) replace any string with value. regexReplace($pattern, $replacement) replace any string with value using regular expression. appendIfMatches($pattern, $text) Append the provided text to the end of the buffer if the provided appendUnlessMatches($pattern, $text) Append the provided text to the end of the buffer unless the provided originalContents() @return string wouldChange() @return bool getPath() @return string setOutput($output) Sets the Console Output.","title":"Write"},{"location":"tasks/Filesystem/","text":"Filesystem Tasks CleanDir Deletes all files from specified dir, ignoring git files. <?php $this->taskCleanDir(['tmp','logs'])->run(); // as shortcut $this->_cleanDir('app/cache'); ?> setOutput($output) Sets the Console Output. CopyDir Copies one dir into another <?php $this->taskCopyDir(['dist/config' => 'config'])->run(); // as shortcut $this->_copyDir('dist/config', 'config'); ?> dirPermissions($value) Sets the default folder permissions for the destination if it doesn't exist exclude($exclude = null) List files to exclude. overwrite($overwrite) Destination files newer than source files are overwritten. setOutput($output) Sets the Console Output. DeleteDir Deletes dir <?php $this->taskDeleteDir('tmp')->run(); // as shortcut $this->_deleteDir(['tmp', 'log']); ?> setOutput($output) Sets the Console Output. FilesystemStack Wrapper for Symfony Filesystem Component. Comands are executed in stack and can be stopped on first fail with stopOnFail option. <?php $this->taskFilesystemStack() ->mkdir('logs') ->touch('logs/.gitignore') ->chgrp('www', 'www-data') ->symlink('/var/log/nginx/error.log', 'logs/error.log') ->run(); // one line $this->_touch('.gitignore'); $this->_mkdir('logs'); ?> $this mkdir(string|array|\\Traversable $dir, int $mode = 0777) $this touch(string|array|\\Traversable $file, int $time = null, int $atime = null) $this copy(string $from, string $to, bool $force = false) $this chmod(string|array|\\Traversable $file, int $permissions, int $umask = 0000, bool $recursive = false) $this chgrp(string|array|\\Traversable $file, string $group, bool $recursive = false) $this chown(string|array|\\Traversable $file, string $user, bool $recursive = false) $this remove(string|array|\\Traversable $file) $this rename(string $from, string $to, bool $force = false) $this symlink(string $from, string $to, bool $copyOnWindows = false) $this mirror(string $from, string $to, \\Traversable $iterator = null, array $options = []) stopOnFail($stop = null) * param bool $stop setOutput($output) Sets the Console Output. FlattenDir Searches for files in a nested directory structure and copies them to a target directory with or without the parent directories. The task was inspired by gulp-flatten . Example directory structure: \u2514\u2500\u2500 assets \u251c\u2500\u2500 asset-library1 \u2502 \u251c\u2500\u2500 README.md \u2502 \u2514\u2500\u2500 asset-library1.min.js \u2514\u2500\u2500 asset-library2 \u251c\u2500\u2500 README.md \u2514\u2500\u2500 asset-library2.min.js The following code will search the *.min.js files and copy them inside a new dist folder: <?php $this->taskFlattenDir(['assets/*.min.js' => 'dist'])->run(); // or use shortcut $this->_flattenDir('assets/*.min.js', 'dist'); ?> You can also define the target directory with an additional method, instead of key/value pairs. More similar to the gulp-flatten syntax: <?php $this->taskFlattenDir(['assets/*.min.js']) ->to('dist') ->run(); ?> You can also append parts of the parent directories to the target path. If you give the value 1 to the includeParents() method, then the top parent will be appended to the target directory resulting in a path such as dist/assets/asset-library1.min.js . If you give a negative number, such as -1 (the same as specifying array(0, 1) then the bottom parent will be appended, resulting in a path such as dist/asset-library1/asset-library1.min.js . The top parent directory will always be starting from the relative path to the current directory. You can override that with the parentDir() method. If in the above example you would specify assets , then the top parent directory would be asset-library1 . <?php $this->taskFlattenDir(['assets/*.min.js' => 'dist']) ->parentDir('assets') ->includeParents(1) ->run(); ?> dirPermissions($permission) Sets the default folder permissions for the destination if it does not exist. includeParents($parents) Sets the value from which direction and how much parent dirs should be included. parentDir($dir) Sets the parent directory from which the relative parent directories will be calculated. to($target) Sets the target directory where the files will be copied to. setOutput($output) Sets the Console Output. MirrorDir Mirrors a directory to another <?php $this->taskMirrorDir(['dist/config/' => 'config/'])->run(); // or use shortcut $this->_mirrorDir('dist/config/', 'config/'); ?> setOutput($output) Sets the Console Output. TmpDir Create a temporary directory that is automatically cleaned up once the task collection is is part of completes. Use WorkDir if you do not want the directory to be deleted. <?php // Delete on rollback or on successful completion. // Note that in this example, everything is deleted at // the end of $collection->run(). $collection = $this->collectionBuilder(); $tmpPath = $collection->tmpDir()->getPath(); $collection->taskFilesystemStack() ->mkdir(\"$tmpPath/log\") ->touch(\"$tmpPath/log/error.txt\"); $collection->run(); // as shortcut (deleted when program exits) $tmpPath = $this->_tmpDir(); ?> cwd($shouldChangeWorkingDirectory = null) Flag that we should cwd to the temporary directory when it is complete() Delete this directory when our collection completes. getPath() Get a reference to the path to the temporary directory, so that setOutput($output) Sets the Console Output. WorkDir Create a temporary working directory that is automatically renamed to its final desired location if all of the tasks in the collection succeed. If there is a rollback, then the working directory is deleted. <?php $collection = $this->collectionBuilder(); $workingPath = $collection->workDir(\"build\")->getPath(); $collection->taskFilesystemStack() ->mkdir(\"$workingPath/log\") ->touch(\"$workingPath/log/error.txt\"); $collection->run(); ?> complete() Move our working directory into its final destination once the rollback() Delete our working directory getPath() Get a reference to the path to the temporary directory, so that cwd($shouldChangeWorkingDirectory = null) Flag that we should cwd to the temporary directory when it is setOutput($output) Sets the Console Output.","title":"Filesystem Tasks"},{"location":"tasks/Filesystem/#filesystem-tasks","text":"","title":"Filesystem Tasks"},{"location":"tasks/Filesystem/#cleandir","text":"Deletes all files from specified dir, ignoring git files. <?php $this->taskCleanDir(['tmp','logs'])->run(); // as shortcut $this->_cleanDir('app/cache'); ?> setOutput($output) Sets the Console Output.","title":"CleanDir"},{"location":"tasks/Filesystem/#copydir","text":"Copies one dir into another <?php $this->taskCopyDir(['dist/config' => 'config'])->run(); // as shortcut $this->_copyDir('dist/config', 'config'); ?> dirPermissions($value) Sets the default folder permissions for the destination if it doesn't exist exclude($exclude = null) List files to exclude. overwrite($overwrite) Destination files newer than source files are overwritten. setOutput($output) Sets the Console Output.","title":"CopyDir"},{"location":"tasks/Filesystem/#deletedir","text":"Deletes dir <?php $this->taskDeleteDir('tmp')->run(); // as shortcut $this->_deleteDir(['tmp', 'log']); ?> setOutput($output) Sets the Console Output.","title":"DeleteDir"},{"location":"tasks/Filesystem/#filesystemstack","text":"Wrapper for Symfony Filesystem Component. Comands are executed in stack and can be stopped on first fail with stopOnFail option. <?php $this->taskFilesystemStack() ->mkdir('logs') ->touch('logs/.gitignore') ->chgrp('www', 'www-data') ->symlink('/var/log/nginx/error.log', 'logs/error.log') ->run(); // one line $this->_touch('.gitignore'); $this->_mkdir('logs'); ?> $this mkdir(string|array|\\Traversable $dir, int $mode = 0777) $this touch(string|array|\\Traversable $file, int $time = null, int $atime = null) $this copy(string $from, string $to, bool $force = false) $this chmod(string|array|\\Traversable $file, int $permissions, int $umask = 0000, bool $recursive = false) $this chgrp(string|array|\\Traversable $file, string $group, bool $recursive = false) $this chown(string|array|\\Traversable $file, string $user, bool $recursive = false) $this remove(string|array|\\Traversable $file) $this rename(string $from, string $to, bool $force = false) $this symlink(string $from, string $to, bool $copyOnWindows = false) $this mirror(string $from, string $to, \\Traversable $iterator = null, array $options = []) stopOnFail($stop = null) * param bool $stop setOutput($output) Sets the Console Output.","title":"FilesystemStack"},{"location":"tasks/Filesystem/#flattendir","text":"Searches for files in a nested directory structure and copies them to a target directory with or without the parent directories. The task was inspired by gulp-flatten . Example directory structure: \u2514\u2500\u2500 assets \u251c\u2500\u2500 asset-library1 \u2502 \u251c\u2500\u2500 README.md \u2502 \u2514\u2500\u2500 asset-library1.min.js \u2514\u2500\u2500 asset-library2 \u251c\u2500\u2500 README.md \u2514\u2500\u2500 asset-library2.min.js The following code will search the *.min.js files and copy them inside a new dist folder: <?php $this->taskFlattenDir(['assets/*.min.js' => 'dist'])->run(); // or use shortcut $this->_flattenDir('assets/*.min.js', 'dist'); ?> You can also define the target directory with an additional method, instead of key/value pairs. More similar to the gulp-flatten syntax: <?php $this->taskFlattenDir(['assets/*.min.js']) ->to('dist') ->run(); ?> You can also append parts of the parent directories to the target path. If you give the value 1 to the includeParents() method, then the top parent will be appended to the target directory resulting in a path such as dist/assets/asset-library1.min.js . If you give a negative number, such as -1 (the same as specifying array(0, 1) then the bottom parent will be appended, resulting in a path such as dist/asset-library1/asset-library1.min.js . The top parent directory will always be starting from the relative path to the current directory. You can override that with the parentDir() method. If in the above example you would specify assets , then the top parent directory would be asset-library1 . <?php $this->taskFlattenDir(['assets/*.min.js' => 'dist']) ->parentDir('assets') ->includeParents(1) ->run(); ?> dirPermissions($permission) Sets the default folder permissions for the destination if it does not exist. includeParents($parents) Sets the value from which direction and how much parent dirs should be included. parentDir($dir) Sets the parent directory from which the relative parent directories will be calculated. to($target) Sets the target directory where the files will be copied to. setOutput($output) Sets the Console Output.","title":"FlattenDir"},{"location":"tasks/Filesystem/#mirrordir","text":"Mirrors a directory to another <?php $this->taskMirrorDir(['dist/config/' => 'config/'])->run(); // or use shortcut $this->_mirrorDir('dist/config/', 'config/'); ?> setOutput($output) Sets the Console Output.","title":"MirrorDir"},{"location":"tasks/Filesystem/#tmpdir","text":"Create a temporary directory that is automatically cleaned up once the task collection is is part of completes. Use WorkDir if you do not want the directory to be deleted. <?php // Delete on rollback or on successful completion. // Note that in this example, everything is deleted at // the end of $collection->run(). $collection = $this->collectionBuilder(); $tmpPath = $collection->tmpDir()->getPath(); $collection->taskFilesystemStack() ->mkdir(\"$tmpPath/log\") ->touch(\"$tmpPath/log/error.txt\"); $collection->run(); // as shortcut (deleted when program exits) $tmpPath = $this->_tmpDir(); ?> cwd($shouldChangeWorkingDirectory = null) Flag that we should cwd to the temporary directory when it is complete() Delete this directory when our collection completes. getPath() Get a reference to the path to the temporary directory, so that setOutput($output) Sets the Console Output.","title":"TmpDir"},{"location":"tasks/Filesystem/#workdir","text":"Create a temporary working directory that is automatically renamed to its final desired location if all of the tasks in the collection succeed. If there is a rollback, then the working directory is deleted. <?php $collection = $this->collectionBuilder(); $workingPath = $collection->workDir(\"build\")->getPath(); $collection->taskFilesystemStack() ->mkdir(\"$workingPath/log\") ->touch(\"$workingPath/log/error.txt\"); $collection->run(); ?> complete() Move our working directory into its final destination once the rollback() Delete our working directory getPath() Get a reference to the path to the temporary directory, so that cwd($shouldChangeWorkingDirectory = null) Flag that we should cwd to the temporary directory when it is setOutput($output) Sets the Console Output.","title":"WorkDir"},{"location":"tasks/Gulp/","text":"Gulp Tasks Run Gulp Run <?php // simple execution $this->taskGulpRun()->run(); // run task 'clean' with --silent option $this->taskGulpRun('clean') ->silent() ->run(); ?> noColor() adds --no-color option to gulp color() adds --color option to gulp simple() adds --tasks-simple option to gulp setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Gulp Tasks"},{"location":"tasks/Gulp/#gulp-tasks","text":"","title":"Gulp Tasks"},{"location":"tasks/Gulp/#run","text":"Gulp Run <?php // simple execution $this->taskGulpRun()->run(); // run task 'clean' with --silent option $this->taskGulpRun('clean') ->silent() ->run(); ?> noColor() adds --no-color option to gulp color() adds --color option to gulp simple() adds --tasks-simple option to gulp setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Run"},{"location":"tasks/Logfile/","text":"Logfile Tasks RotateLog Rotates a log (or any other) file <?php $this->taskRotateLog(['logfile.log'])->run(); // or use shortcut $this->_rotateLog(['logfile.log']); ?> keep($keep) * param int $keep chmod($chmod) * param int $chmod setOutput($output) Sets the Console Output. TruncateLog Truncates a log (or any other) file <?php $this->taskTruncateLog(['logfile.log'])->run(); // or use shortcut $this->_truncateLog(['logfile.log']); ?> chmod($chmod) * param int $chmod setOutput($output) Sets the Console Output.","title":"Logfile Tasks"},{"location":"tasks/Logfile/#logfile-tasks","text":"","title":"Logfile Tasks"},{"location":"tasks/Logfile/#rotatelog","text":"Rotates a log (or any other) file <?php $this->taskRotateLog(['logfile.log'])->run(); // or use shortcut $this->_rotateLog(['logfile.log']); ?> keep($keep) * param int $keep chmod($chmod) * param int $chmod setOutput($output) Sets the Console Output.","title":"RotateLog"},{"location":"tasks/Logfile/#truncatelog","text":"Truncates a log (or any other) file <?php $this->taskTruncateLog(['logfile.log'])->run(); // or use shortcut $this->_truncateLog(['logfile.log']); ?> chmod($chmod) * param int $chmod setOutput($output) Sets the Console Output.","title":"TruncateLog"},{"location":"tasks/Npm/","text":"Npm Tasks Install Npm Install <?php // simple execution $this->taskNpmInstall()->run(); // prefer dist with custom path $this->taskNpmInstall('path/to/my/npm') ->noDev() ->run(); ?> noDev() adds production option to npm setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Update Npm Update <?php // simple execution $this->taskNpmUpdate()->run(); // prefer dist with custom path $this->taskNpmUpdate('path/to/my/npm') ->noDev() ->run(); ?> noDev() adds production option to npm setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Npm Tasks"},{"location":"tasks/Npm/#npm-tasks","text":"","title":"Npm Tasks"},{"location":"tasks/Npm/#install","text":"Npm Install <?php // simple execution $this->taskNpmInstall()->run(); // prefer dist with custom path $this->taskNpmInstall('path/to/my/npm') ->noDev() ->run(); ?> noDev() adds production option to npm setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Install"},{"location":"tasks/Npm/#update","text":"Npm Update <?php // simple execution $this->taskNpmUpdate()->run(); // prefer dist with custom path $this->taskNpmUpdate('path/to/my/npm') ->noDev() ->run(); ?> noDev() adds production option to npm setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Update"},{"location":"tasks/Remote/","text":"Remote Tasks Rsync Executes rsync in a flexible manner. $this->taskRsync() ->fromPath('src/') ->toHost('localhost') ->toUser('dev') ->toPath('/var/www/html/app/') ->remoteShell('ssh -i public_key') ->recursive() ->excludeVcs() ->checksum() ->wholeFile() ->verbose() ->progress() ->humanReadable() ->stats() ->run(); You could also clone the task and do a dry-run first: $rsync = $this->taskRsync() ->fromPath('src/') ->toPath('example.com:/var/www/html/app/') ->archive() ->excludeVcs() ->progress() ->stats(); $dryRun = clone $rsync; $dryRun->dryRun()->run(); if ('y' === $this->ask('Do you want to run (y/n)')) { $rsync->run(); } fromPath($path) This can either be a full rsync path spec (user@host:path) or just a path. toPath($path) This can either be a full rsync path spec (user@host:path) or just a path. fromUser($fromUser) * param string $fromUser fromHost($fromHost) * param string $fromHost toUser($toUser) * param string $toUser toHost($toHost) * param string $toHost progress() * return $this stats() * return $this recursive() * return $this verbose() * return $this checksum() * return $this archive() * return $this compress() * return $this owner() * return $this group() * return $this times() * return $this delete() * return $this humanReadable() * return $this wholeFile() * return $this dryRun() * return $this itemizeChanges() * return $this excludeVcs() Excludes .git, .svn and .hg items at any depth. exclude($pattern) * param array|string $pattern excludeFrom($file) * param string $file includeFilter($pattern) * param array|string $pattern filter($pattern) * param array|string $pattern filesFrom($file) * param string $file remoteShell($command) * param string $command setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Ssh Runs multiple commands on a remote server. Per default, commands are combined with &&, unless stopOnFail is false. <?php $this->taskSshExec('remote.example.com', 'user') ->remoteDir('/var/www/html') ->exec('ls -la') ->exec('chmod g+x logs') ->run(); You can even exec other tasks (which implement CommandInterface): $gitTask = $this->taskGitStack() ->checkout('master') ->pull(); $this->taskSshExec('remote.example.com') ->remoteDir('/var/www/html/site') ->exec($gitTask) ->run(); You can configure the remote directory for all future calls: ::configure('remoteDir', '/some-dir'); hostname($hostname) * param string $hostname user($user) * param string $user stopOnFail($stopOnFail = null) Whether or not to chain commands together with && and stop the chain if one command fails. remoteDir($remoteDir) Changes to the given directory before running commands. identityFile($filename) * param string $filename port($port) * param int $port forcePseudoTty() * return $this quiet() * return $this verbose() * return $this exec($command) * param string|string[]|CommandInterface $command simulate($context) {@inheritdoc} setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Remote Tasks"},{"location":"tasks/Remote/#remote-tasks","text":"","title":"Remote Tasks"},{"location":"tasks/Remote/#rsync","text":"Executes rsync in a flexible manner. $this->taskRsync() ->fromPath('src/') ->toHost('localhost') ->toUser('dev') ->toPath('/var/www/html/app/') ->remoteShell('ssh -i public_key') ->recursive() ->excludeVcs() ->checksum() ->wholeFile() ->verbose() ->progress() ->humanReadable() ->stats() ->run(); You could also clone the task and do a dry-run first: $rsync = $this->taskRsync() ->fromPath('src/') ->toPath('example.com:/var/www/html/app/') ->archive() ->excludeVcs() ->progress() ->stats(); $dryRun = clone $rsync; $dryRun->dryRun()->run(); if ('y' === $this->ask('Do you want to run (y/n)')) { $rsync->run(); } fromPath($path) This can either be a full rsync path spec (user@host:path) or just a path. toPath($path) This can either be a full rsync path spec (user@host:path) or just a path. fromUser($fromUser) * param string $fromUser fromHost($fromHost) * param string $fromHost toUser($toUser) * param string $toUser toHost($toHost) * param string $toHost progress() * return $this stats() * return $this recursive() * return $this verbose() * return $this checksum() * return $this archive() * return $this compress() * return $this owner() * return $this group() * return $this times() * return $this delete() * return $this humanReadable() * return $this wholeFile() * return $this dryRun() * return $this itemizeChanges() * return $this excludeVcs() Excludes .git, .svn and .hg items at any depth. exclude($pattern) * param array|string $pattern excludeFrom($file) * param string $file includeFilter($pattern) * param array|string $pattern filter($pattern) * param array|string $pattern filesFrom($file) * param string $file remoteShell($command) * param string $command setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Rsync"},{"location":"tasks/Remote/#ssh","text":"Runs multiple commands on a remote server. Per default, commands are combined with &&, unless stopOnFail is false. <?php $this->taskSshExec('remote.example.com', 'user') ->remoteDir('/var/www/html') ->exec('ls -la') ->exec('chmod g+x logs') ->run(); You can even exec other tasks (which implement CommandInterface): $gitTask = $this->taskGitStack() ->checkout('master') ->pull(); $this->taskSshExec('remote.example.com') ->remoteDir('/var/www/html/site') ->exec($gitTask) ->run(); You can configure the remote directory for all future calls: ::configure('remoteDir', '/some-dir'); hostname($hostname) * param string $hostname user($user) * param string $user stopOnFail($stopOnFail = null) Whether or not to chain commands together with && and stop the chain if one command fails. remoteDir($remoteDir) Changes to the given directory before running commands. identityFile($filename) * param string $filename port($port) * param int $port forcePseudoTty() * return $this quiet() * return $this verbose() * return $this exec($command) * param string|string[]|CommandInterface $command simulate($context) {@inheritdoc} setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Ssh"},{"location":"tasks/Testing/","text":"Testing Tasks Atoum Runs atoum tests <?php $this->taskAtoum() ->files('path/to/test.php') ->configFile('config/dev.php') ->run() ?> tags($tags) Tag or Tags to filter. lightReport() Display result using the light reporter. tap() Display result using the tap reporter. bootstrap($file) Path to the bootstrap file. configFile($file) Path to the config file. debug() Use atoum's debug mode. files($files) Test file or test files to run. directories($directories) Test directory or directories to run. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Behat Executes Behat tests <?php $this->taskBehat() ->format('pretty') ->noInteraction() ->run(); ?> stopOnFail() * return $this noInteraction() * return $this config($config_file) * param string $config_file colors() * return $this noColors() * return $this suite($suite) * param string $suite verbose($level = null) * param string $level format($formater) * param string $formater setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Codecept Executes Codeception tests <?php // config $this->taskCodecept() ->suite('acceptance') ->env('chrome') ->group('admin') ->xml() ->html() ->run(); ?> suite($suite) * param string $suite test($testName) * param string $testName group($group) set group option. Can be called multiple times excludeGroup($group) * param string $group json($file = null) generate json report xml($file = null) generate xml JUnit report html($dir = null) Generate html report tap($file = null) generate tap report configFile($file) provides config file other then default codeception.yml with -c option coverage($cov = null) collect codecoverage in raw format. You may pass name of cov file to save results coverageXml($xml = null) collect code coverage in xml format. You may pass name of xml file to save results coverageHtml($html = null) collect code coverage and generate html report. You may pass debug() * return $this noRebuild() * return $this noExit() * return $this failGroup($failGroup) * param string $failGroup setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. PHPUnit Runs PHPUnit tests <?php $this->taskPHPUnit() ->group('core') ->bootstrap('test/bootstrap.php') ->run() ?> filter($filter) * param string $filter group($group) * param string $group excludeGroup($group) * param string $group json($file = null) adds log-json option to runner xml($file = null) adds log-junit option tap($file = null) * param string $file bootstrap($file) * param string $file configFile($file) * param string $file debug() * return $this files($files) Directory of test files or single test file to run. file($file) Test the provided file. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array. Phpspec Executes Phpspec tests <?php $this->taskPhpspec() ->format('pretty') ->noInteraction() ->run(); ?> stopOnFail() noCodeGeneration() quiet() verbose($level = null) * param string $level noAnsi() * return $this noInteraction() * return $this config($config_file) * param string $config_file format($formater) * param string $formater setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Testing Tasks"},{"location":"tasks/Testing/#testing-tasks","text":"","title":"Testing Tasks"},{"location":"tasks/Testing/#atoum","text":"Runs atoum tests <?php $this->taskAtoum() ->files('path/to/test.php') ->configFile('config/dev.php') ->run() ?> tags($tags) Tag or Tags to filter. lightReport() Display result using the light reporter. tap() Display result using the tap reporter. bootstrap($file) Path to the bootstrap file. configFile($file) Path to the config file. debug() Use atoum's debug mode. files($files) Test file or test files to run. directories($directories) Test directory or directories to run. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Atoum"},{"location":"tasks/Testing/#behat","text":"Executes Behat tests <?php $this->taskBehat() ->format('pretty') ->noInteraction() ->run(); ?> stopOnFail() * return $this noInteraction() * return $this config($config_file) * param string $config_file colors() * return $this noColors() * return $this suite($suite) * param string $suite verbose($level = null) * param string $level format($formater) * param string $formater setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Behat"},{"location":"tasks/Testing/#codecept","text":"Executes Codeception tests <?php // config $this->taskCodecept() ->suite('acceptance') ->env('chrome') ->group('admin') ->xml() ->html() ->run(); ?> suite($suite) * param string $suite test($testName) * param string $testName group($group) set group option. Can be called multiple times excludeGroup($group) * param string $group json($file = null) generate json report xml($file = null) generate xml JUnit report html($dir = null) Generate html report tap($file = null) generate tap report configFile($file) provides config file other then default codeception.yml with -c option coverage($cov = null) collect codecoverage in raw format. You may pass name of cov file to save results coverageXml($xml = null) collect code coverage in xml format. You may pass name of xml file to save results coverageHtml($html = null) collect code coverage and generate html report. You may pass debug() * return $this noRebuild() * return $this noExit() * return $this failGroup($failGroup) * param string $failGroup setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Codecept"},{"location":"tasks/Testing/#phpunit","text":"Runs PHPUnit tests <?php $this->taskPHPUnit() ->group('core') ->bootstrap('test/bootstrap.php') ->run() ?> filter($filter) * param string $filter group($group) * param string $group excludeGroup($group) * param string $group json($file = null) adds log-json option to runner xml($file = null) adds log-junit option tap($file = null) * param string $file bootstrap($file) * param string $file configFile($file) * param string $file debug() * return $this files($files) Directory of test files or single test file to run. file($file) Test the provided file. setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"PHPUnit"},{"location":"tasks/Testing/#phpspec","text":"Executes Phpspec tests <?php $this->taskPhpspec() ->format('pretty') ->noInteraction() ->run(); ?> stopOnFail() noCodeGeneration() quiet() verbose($level = null) * param string $level noAnsi() * return $this noInteraction() * return $this config($config_file) * param string $config_file format($formater) * param string $formater setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command arg($arg) Pass argument to executable. Its value will be automatically escaped. args($args) Pass methods parameters as arguments to executable. Argument values rawArg($arg) Pass the provided string in its raw (as provided) form as an argument to executable. option($option, $value = null, $separator = null) Pass option to executable. Options are prefixed with -- , value can be provided in second parameter. options(array $options, $separator = null) Pass multiple options to executable. The associative array contains optionList($option, $value = null, $separator = null) Pass an option with multiple values to executable. Value can be a string or array.","title":"Phpspec"},{"location":"tasks/Vcs/","text":"Vcs Tasks GitStack Runs Git commands in stack. You can use stopOnFail() to point that stack should be terminated on first fail. <?php $this->taskGitStack() ->stopOnFail() ->add('-A') ->commit('adding everything') ->push('origin','master') ->tag('0.6.0') ->push('origin','0.6.0') ->run() $this->taskGitStack() ->stopOnFail() ->add('doc/*') ->commit('doc updated') ->push() ->run(); ?> cloneRepo($repo, $to = null, $branch = null) Executes git clone cloneShallow($repo, $to = null, $branch = null, $depth = null) Executes git clone with depth 1 as default add($pattern) Executes git add command with files to add pattern commit($message, $options = null) Executes git commit command with a message pull($origin = null, $branch = null) Executes git pull command. push($origin = null, $branch = null) Executes git push command merge($branch) Performs git merge checkout($branch) Executes git checkout command tag($tag_name, $message = null) Executes git tag command executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command HgStack Runs hg commands in stack. You can use stopOnFail() to point that stack should be terminated on first fail. <?php $this->hgStack ->cloneRepo('https://bitbucket.org/durin42/hgsubversion') ->pull() ->add() ->commit('changed') ->push() ->tag('0.6.0') ->push('0.6.0') ->run(); ?> cloneRepo($repo, $to = null) Executes hg clone add($include = null, $exclude = null) Executes hg add command with files to add by pattern commit($message, $options = null) Executes hg commit command with a message pull($branch = null) Executes hg pull command. push($branch = null) Executes hg push command merge($revision = null) Performs hg merge tag($tag_name, $message = null) Executes hg tag command executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command SvnStack Runs Svn commands in stack. You can use stopOnFail() to point that stack should be terminated on first fail. <?php $this->taskSvnStack() ->checkout('http://svn.collab.net/repos/svn/trunk') ->run() // alternatively $this->_svnCheckout('http://svn.collab.net/repos/svn/trunk'); $this->taskSvnStack('username', 'password') ->stopOnFail() ->update() ->add('doc/*') ->commit('doc updated') ->run(); ?> update($path = null) Updates svn update command add($pattern = null) Executes svn add command with files to add pattern commit($message, $options = null) Executes svn commit command with a message checkout($branch) Executes svn checkout command executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command","title":"Vcs Tasks"},{"location":"tasks/Vcs/#vcs-tasks","text":"","title":"Vcs Tasks"},{"location":"tasks/Vcs/#gitstack","text":"Runs Git commands in stack. You can use stopOnFail() to point that stack should be terminated on first fail. <?php $this->taskGitStack() ->stopOnFail() ->add('-A') ->commit('adding everything') ->push('origin','master') ->tag('0.6.0') ->push('origin','0.6.0') ->run() $this->taskGitStack() ->stopOnFail() ->add('doc/*') ->commit('doc updated') ->push() ->run(); ?> cloneRepo($repo, $to = null, $branch = null) Executes git clone cloneShallow($repo, $to = null, $branch = null, $depth = null) Executes git clone with depth 1 as default add($pattern) Executes git add command with files to add pattern commit($message, $options = null) Executes git commit command with a message pull($origin = null, $branch = null) Executes git pull command. push($origin = null, $branch = null) Executes git push command merge($branch) Performs git merge checkout($branch) Executes git checkout command tag($tag_name, $message = null) Executes git tag command executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command","title":"GitStack"},{"location":"tasks/Vcs/#hgstack","text":"Runs hg commands in stack. You can use stopOnFail() to point that stack should be terminated on first fail. <?php $this->hgStack ->cloneRepo('https://bitbucket.org/durin42/hgsubversion') ->pull() ->add() ->commit('changed') ->push() ->tag('0.6.0') ->push('0.6.0') ->run(); ?> cloneRepo($repo, $to = null) Executes hg clone add($include = null, $exclude = null) Executes hg add command with files to add by pattern commit($message, $options = null) Executes hg commit command with a message pull($branch = null) Executes hg pull command. push($branch = null) Executes hg push command merge($revision = null) Performs hg merge tag($tag_name, $message = null) Executes hg tag command executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command","title":"HgStack"},{"location":"tasks/Vcs/#svnstack","text":"Runs Svn commands in stack. You can use stopOnFail() to point that stack should be terminated on first fail. <?php $this->taskSvnStack() ->checkout('http://svn.collab.net/repos/svn/trunk') ->run() // alternatively $this->_svnCheckout('http://svn.collab.net/repos/svn/trunk'); $this->taskSvnStack('username', 'password') ->stopOnFail() ->update() ->add('doc/*') ->commit('doc updated') ->run(); ?> update($path = null) Updates svn update command add($pattern = null) Executes svn add command with files to add pattern commit($message, $options = null) Executes svn commit command with a message checkout($branch) Executes svn checkout command executable($executable) * param string $executable exec($command) * param string|string[]|CommandInterface $command stopOnFail($stopOnFail = null) * param bool $stopOnFail result($result) setOutput($output) Sets the Console Output. setProcessInput($input) Pass an input to the process. Can be resource created with fopen() or string dir($dir) Changes working directory of command","title":"SvnStack"}]}